<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>phpunit on Alfred Nutile</title><link>https://alfrednutile.info/tags/phpunit/</link><description>Recent content in phpunit on Alfred Nutile</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 09 Jan 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://alfrednutile.info/tags/phpunit/index.xml" rel="self" type="application/rss+xml"/><item><title>PHPUnit CodeCoverage</title><link>https://alfrednutile.info/posts/260/</link><pubDate>Wed, 09 Jan 2019 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/260/</guid><description><h1 id="phpunit-codecoverage">PHPUnit CodeCoverage</h1><p><a href="https://phpunit.de/manual/6.5/en/code-coverage-analysis.html">PHPUnit CodeCoverage</a></p><p>There is a ton of information about your code PHPUNit CodeCoverage can provide. At the root just making sure your coverage is at a certain level and if not where is it lacking.</p><p>With it&rsquo;s xml output I use a script found<a href="https://ocramius.github.io/blog/automated-code-coverage-check-for-github-pull-requests-with-travis/">here</a> to check during our TravisCI builds if the code is meeting a required level.</p><p>Here is a gist of that script<a href="https://gist.github.com/alnutile/78e11717d91f2dfce970f8f1aec68469">here</a>
and here is the<code>.travis.yml</code> section snippet that will run the coverage generating test and then review it for percentage of coverage.</p><pre><code>script:
- vendor/bin/phpcs --standard=psr2 app/
- set -e
- vendor/bin/phpunit --coverage-clover clover.xml --stop-on-failure --testsuite=Unit,Feature
- php ./coverage-checker.php clover.xml 70<p/></pre><p>This is what we run in Travis to review the coverage, if it is below<strong>70</strong>% it will fail.</p></p><blockquote><p>If your unit tests cover 100% of your code, you&rsquo;re doing it wrong.
Just my 2 cts. - Fabien Potencier</p></blockquote><h2 id="setting-up">Setting Up</h2><p>This can be tricky you need Xdebug in place else you might get &ldquo;Coverage driver missing&rdquo; errors.</p><p>Once ready you need to update your<code>phpunit.xml</code> here is my example:</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;phpunit
/// left out some area for brevity
&lt;testsuites>
&lt;testsuite name="Unit">
&lt;directory suffix="Test.php">./tests/Unit&lt;/directory>
&lt;/testsuite><pre><code> &amp;lt;testsuite name=&amp;quot;Feature&amp;quot;&amp;gt;
&amp;lt;directory suffix=&amp;quot;Test.php&amp;quot;&amp;gt;./tests/Feature&amp;lt;/directory&amp;gt;
&amp;lt;/testsuite&amp;gt;
&amp;lt;/testsuites&amp;gt;
&amp;lt;filter&amp;gt;
&amp;lt;whitelist processUncoveredFilesFromWhitelist=&amp;quot;true&amp;quot;&amp;gt;
&amp;lt;directory suffix=&amp;quot;.php&amp;quot;&amp;gt;./app&amp;lt;/directory&amp;gt;
&amp;lt;exclude&amp;gt;
&amp;lt;directory suffix=&amp;quot;.php&amp;quot;&amp;gt;app/Http/Controllers/Auth&amp;lt;/directory&amp;gt;
&amp;lt;file&amp;gt;app/Console/Commands/SetupDeploymentCommand.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Console/Kernel.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Kernel.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Providers/AppServiceProvider.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Providers/AuthServiceProvider.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Providers/EventServiceProvider.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Providers/BroadcastServiceProvider.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Providers/RouteServiceProvider.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Controllers/Controller.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Exceptions/Handler.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Middleware/Authenticate.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Middleware/EncryptCookies.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Middleware/RedirectIfAuthenticated.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Middleware/TrimStrings.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Middleware/TrustProxies.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Middleware/VerifyCsrfToken.php&amp;lt;/file&amp;gt;
&amp;lt;/exclude&amp;gt;
&amp;lt;/whitelist&amp;gt;
&amp;lt;/filter&amp;gt;
/// left out some area for brevity</code></pre><p>&lt;/phpunit></p><p/></pre><p>Above I setup<code>filter</code> to exclude a bunch of Laravel files I do not want to maintain.</p></p><h2 id="running-the-command">Running the Command</h2><pre><code>vendor/bin/phpunit --coverage-clover clover.xml --stop-on-failure --coverage-html=build</code></pre><p>This will output the clover.xml and make a folder called<code>build</code> make sure to include that in your<code>.gitignore</code></p><p>On my Mac, when done, I just type<code>open build/index.html</code> and I go to a page like this</p><p><img src="https://dl.dropboxusercontent.com/s/vnmt5iy909hycid/Screenshot%202019-01-09%2012.02.29.png?dl=0" alt=""/><h2 id="exploring">Exploring</h2><p>As seen above I get a list of all my classes and how the coverage is on each them. It gets even better from here.</p><h3 id="class-level">Class Level</h3><p>So you are wondering why a class is missing coverage? Click on the Class folder and start to dig in.</p><p><img src="https://dl.dropboxusercontent.com/s/ii7yqczoviw0vpz/Screenshot%202019-01-09%2012.22.23.png?dl=0" alt=""/><p>Maybe it finds something you forgot or maybe it is fussing about a bit of code you know you tested?</p><p>In this example it could be either. So I have two main options.</p><h4 id="annotate-the-test">Annotate the test</h4><p>Let&rsquo;s say I have a Controller level test that is testing this:</p><pre><code> /**
* @covers App\Http\Controllers\AdminController::index
*/
public function testWorksAsAdmin()
{
$user = factory(\App\User::class)->states('admin')->create();
$this->be($user);
$this->get("/admin")->assertStatus(200)->assertSee("Show user");
}<pre><code>/**
* @covers App\Http\Controllers\AdminController::index
*/
public function testWorksAsNonAdmin()
{
$user = factory(\App\User::class)-&amp;gt;create();
$this-&amp;gt;be($user);
$this-&amp;gt;get(&amp;quot;/admin&amp;quot;)-&amp;gt;assertStatus(302);
}</code></pre><p/></pre><p>You can see I specifically tell PHPUnit CodeCoverage that this controller tests are testing this area. But I do not let it know about the MiddleWare so I could do:</p></p><pre><code> /**
* @covers App\Http\Controllers\AdminController::index
* @covers App\Http\Controllers\AdminController::__constructor
*/
public function testWorksAsAdmin()
{
$user = factory(\App\User::class)->states('admin')->create();
$this->be($user);
$this->get("/admin")->assertStatus(200)->assertSee("Show user");
}
/**
* @covers App\Http\Controllers\AdminController::index
* @covers App\Http\Controllers\AdminController::__constructor
*/
public function testWorksAsNonAdmin()
{
$user = factory(\App\User::class)->create();
$this->be($user);
$this->get("/admin")->assertStatus(302);
}</code></pre><p>Then run the test command again and:</p><p><img src="https://dl.dropboxusercontent.com/s/gl8m3ompd4s8vw5/Screenshot%202019-01-09%2012.26.43.png?dl=0" alt=""/><h4 id="annotate-the-class">Annotate the Class</h4><p>In the above I could have just done this:</p><pre><code> /**
* @codeCoverageIgnore
*/
public function __construct()
{
$this->middleware('admin_only')->only("index");
}<p/></pre><p>And that is fine, as long as you know that middleware is tested in it’s own area.</p></p><h4 id="exceptions">Exceptions</h4><p>I tend to do try/catch in my controllers to clearly react to an issue and respond to a user&rsquo;s request but this can show in PHPUnit Coverage as a non tested section of code.</p><p>All I need to do is add a test for that.</p><pre><code> /**
* @covers App\Http\Controllers\AdminController::index
* @covers App\Http\Controllers\AdminController::__constructor
* @expectedException \Exception
*/
public function testWorksAsNonAdmin()
{
$user = factory(\App\User::class)->create();
$this->be($user);
$this->get("/admin")->assertStatus(422);
}<p/></pre><h3 id="dashboard">Dashboard</h3></p><p>This is where some other nice info is surfaced about your code.</p><p><img src="https://dl.dropboxusercontent.com/s/9cgvtghsc56iqyk/dashboard_link.png?dl=0" alt=""/><p>Should bring you to this layout</p><p><img src="https://dl.dropboxusercontent.com/s/04vgti8gogembv8/Screenshot%202019-01-09%2012.31.05.png?dl=0" alt=""/><p>The<strong>CRAP</strong> rating is &ldquo;interesting&rdquo; you can read more about it<a href="https://stackoverflow.com/questions/4731774/how-to-read-improve-c-r-a-p-index-calculated-by-php/4731869#4731869">here</a> since I do not fully understand it myself but imo it comes down not to 100% coverage but:</p><ul><li>Keep classes small and focused</li><li>Keep classed down to 1 public method, even Controllers letting other protected/private methods do the work</li><li>Test the class for message in and message out</li></ul><blockquote><p>&ldquo;You don&rsquo;t send messages because you have objects, you have objects because you send messages - Sandi Metz Poodr Book&rdquo;</p></blockquote><h2 id="helpers">Helpers</h2><p>Two other tools to compliment that above</p><h3 id="phpmetrics">PHPMetrics</h3><p>This tool<a href="http://www.phpmetrics.org/">http://www.phpmetrics.org/</a> can easily be setup and run showing more details about your classes and their state of &ldquo;complexity&rdquo; etc.</p><h3 id="larastan">LaraStan</h3><p>This tool<a href="https://github.com/nunomaduro/larastan">https://github.com/nunomaduro/larastan</a> when it does not go overboard in it&rsquo;s reading your code (set it to a low level) can do a good job of finding issues in your code that you did not find in your tests. It runs over your code including exceptions you did not cover in your tests etc. Really does find some interesting things.</p></description><tags>laravel, testing, phpunit</tags></item><item><title>Testing a trait with PHPUnit</title><link>https://alfrednutile.info/posts/212/</link><pubDate>Thu, 08 Jun 2017 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/212/</guid><description><p>In an effort to start recording test coverage using<code>vendor/bin/phpunit --coverage-text --coverage-clover=coverage.clover</code> I had some issues with traits being seen.</p><p>I tried numerous approaches my default being just to<code>Use</code> the trait in the test class. I ended up with this as I found some online info about trait testing<a href="http://blog.florianwolters.de/educational/2012/09/20/Testing-Traits-with-PHPUnit/">here</a> that references a now missing post by Sebastian Bergman the maker of PHPUnit</p><pre><code>&lt;?php<p>use Symfony\Component\Yaml\Yaml;</p><p>/**</p><ul><li><p>Test class for {@see PfawsYaml}.
*</p></li><li><p>@covers \PfAws\Traits\PfawsYaml
*/
class PfawsYamlTest extends TestCase
{</p><p>/**</p><ul><li>The object under test.
*</li><li>@var object
*/
protected $traitObject;</li></ul><p>public function setUp()
{
parent::setUp(); // TODO: Change the autogenerated stub
$this->traitObject = $this->createObjectForTrait();
}</p><p>/**</p><ul><li><p><em>Creation Method</em> to create an object for the trait under test.
*</p></li><li><p>@return object The newly created object.
*/
private function createObjectForTrait()
{
$traitName = &lsquo;\PfAws\Traits\PfawsYaml&rsquo;;</p><p>return $this->getObjectForTrait($traitName);
}</p></li></ul><p>/**</p><ul><li><p>coversDefaultClass loadPfawsYaml
*/
public function testLoadPfawsYaml()
{
$path =<strong>DIR</strong> . &lsquo;/fixtures/pfaws.yaml&rsquo;;</p><p>$results = $this->traitObject->loadPfawsYaml(&lsquo;staging&rsquo;, $path);</p><p>$this->assertEquals("bar2", $results->getPfawsYamlEnv(&lsquo;aws_key&rsquo;));</p><p>$this->assertEquals("foo2", $results->getPfawsYamlEnv(&lsquo;aws_secret&rsquo;));</p><p>$this->assertNotNull($this->traitObject->getPfawsyaml());
}</p></li></ul><p>/**</p><ul><li><p>@coversDefaultClass getPfawsYamlEnv
*/
public function testGetPfawsYamlEnv()
{
$path =<strong>DIR</strong> . &lsquo;/fixtures/pfaws.yaml&rsquo;;</p><p>$results = $this->traitObject->loadPfawsYaml(&lsquo;staging&rsquo;, $path);</p><p>$this->assertEquals("bar2", $results->getPfawsYamlEnv(&lsquo;aws_key&rsquo;));</p><p>$this->assertEquals("foo2", $results->getPfawsYamlEnv(&lsquo;aws_secret&rsquo;));
}</p></li></ul><p>/**</p><ul><li><p>@coversDefaultClass getPfawsyaml
*/
public function testGetPfawsyaml()
{
$path =<strong>DIR</strong> . &lsquo;/fixtures/pfaws.yaml&rsquo;;</p><p>$results = $this->traitObject->loadPfawsYaml(&lsquo;staging&rsquo;, $path);</p><p>$this->assertNotNull($results->getPfawsyaml());</p><p>$this->assertNotNull($results);</p><p>$this->assertEquals("bar2", $results->getPfawsYamlEnv(&lsquo;aws_key&rsquo;));</p><p>$this->assertEquals("foo2", $results->getPfawsYamlEnv(&lsquo;aws_secret&rsquo;));
}</p></li></ul><p>/**</p><ul><li><p>@coversDefaultClass setS3
*/
public function testSetS3() {
$path =<strong>DIR</strong> . &lsquo;/fixtures/pfaws.yaml&rsquo;;
$this->traitObject->loadPfawsYaml(&lsquo;staging&rsquo;, $path);
$this->traitObject->setS3();</p><p>$filesystem = \League\Flysystem\AwsS3v3\AwsS3Adapter::class;
$this->assertInstanceOf($filesystem, $this->traitObject->getS3());
}</p></li></ul><p>/**</p><ul><li><p>@coversDefaultClass getPfawsYamlKeyValue
*/
public function testGetPfawsYamlKeyValue() {
$path =<strong>DIR</strong> . &lsquo;/fixtures/pfaws.yaml&rsquo;;
$this->traitObject->loadPfawsYaml(&lsquo;staging&rsquo;, $path)->setS3();</p><p>$app_name = $this->traitObject->getPfawsYamlKeyValue(&lsquo;app_name&rsquo;);
$this->assertEquals(&lsquo;foo&rsquo;, $app_name);
}
}</p></li></ul></li></ul><p/></pre><p>The annotations are for the coverage to know what I am testing.</p></p><p>This area puts the Trait in to an object using a method provided by PHPUnit:</p><pre><code>/**
* *Creation Method* to create an object for the trait under test.
*
* @return object The newly created object.
*/
private function createObjectForTrait()
{
$traitName = '\PfAws\Traits\PfawsYaml';<pre><code>return $this-&amp;gt;getObjectForTrait($traitName);</code></pre><p>}</code></pre></p><p>And then I run<code>vendor/bin/phpunit --coverage-text --coverage-clover=coverage.clover</code> and the coverage was boosted / recognized.</p><p>On a side note adding to my<code>phpunit.xml</code></p><pre><code> &lt;logging>
&lt;log
type="coverage-html"
target="./docs/coverage"
charset="UTF-8"
yui="true"
lowUpperBound="35"
highLowerBound="70"
showUncoveredFiles="true"
/><pre><code> &amp;lt;log
type=&amp;quot;coverage-text&amp;quot;
target=&amp;quot;php://stdout&amp;quot;
lowUpperBound=&amp;quot;35&amp;quot;
highLowerBound=&amp;quot;70&amp;quot;
/&amp;gt;
&amp;lt;/logging&amp;gt;</code></pre><p/></pre><p>Gave me some really nice code coverage information</p></p><p><img src="https://dl.dropboxusercontent.com/s/2hbocuv8qfyv2u9/code_coverage.png?dl=0" alt=""/></description><tags>php, testing, phpunit</tags></item><item><title>Example of Mixing it up Behat BDD and PHPUnit</title><link>https://alfrednutile.info/posts/185/</link><pubDate>Thu, 23 Jun 2016 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/185/</guid><description><p>Just wanted to show two things here. One is how sometimes I end up in PHPUnit to work out some ideas. And two how awesome it is to refactor thanks to PHPUnit.</p><p>In this example I had a Class responsible for saving data, we&rsquo;ll call FooSaveData. But before that save it has to process some incoming information against another set of data to save the results of that. So I made another class we&rsquo;ll call FooProcessData.</p><p>The BDD Story for this worked out well in that just like in Konstantin Kudryashov noted in this<a href="http://stakeholderwhisperer.com/posts/2014/10/introducing-modelling-by-example#_=_">article</a> I had a great reading business driven gherkin feature that I then, using<a href="http://docs.behat.org/en/v3.0/guides/5.suites.html">Behat 3 and Suites</a> was able to make some really great names for my classes and methods.</p><p>But this was fine as I was working on FooSaveData, but the fact that FooProcessData had to iterate over a large complex array of data I did not want to do inside of this Gherkin test. It would mean that I had to deal with 5 other steps, x number of model states I needed etc. Instead I just made a unit test for that class &ldquo;FooProcessData&rdquo; and focused on it for a bit outside the rest of this work.</p><p>To begin with I just use</p><pre><code>File::put(base_path('tests/fixtures/data_to_process.json', json_encode($some_data, JSON_PRETTY_PRINT))</code></pre><p>to put that data right where I want it for my unit tests.</p><p>Then from there I go around and around unil the thinking on the left reads more like the thinking on the right</p><p><a href="https://dl.dropboxusercontent.com/s/evboprnu04gllrn/example_of_crazy_method_to_readable.png?dl=0"><img src="https://dl.dropboxusercontent.com/s/evboprnu04gllrn/example_of_crazy_method_to_readable.png?dl=0" alt="start to end"/></p><p>Which is my favorite part of this really as I see code evolve to something I can come back 6 months later and read.</p><blockquote><p>Let&rsquo;s Plan for a Future Where We&rsquo;re All As Stupid as We Are Today - Dan Milstein</p></blockquote><p>At this point that &ldquo;lego&rdquo; like piece is done and I can go back to my Behat BDD Gherkin test to finish off where I left off.</p></description><tags>php, laravel, bdd, behat, phpunit</tags></item><item><title>Codeship and Laravel for Continuous Integration</title><link>https://alfrednutile.info/posts/148/</link><pubDate>Sun, 07 Jun 2015 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/148/</guid><description><p>Getting going on Codeship and Laravel is pretty easy.</p><p>Once you setup codeship to work with your github account just pull in your repo and set your Testing scripts as follows. (they have a ui for ENV variables as well)</p><h2 id="codeship-testing-settings-easier-copy-paste-bottom-of-article">Codeship Testing Settings [easier copy paste bottom of article]</h2><p><img src="https://dl.dropboxusercontent.com/s/fh6vv3g5wpqw7ac/codeship1.png?dl=0" alt="codeship"/><p>You can do this in their UI as well. But at this point I am</p><ul><li>Setting up the composer token for any private repos that application might have</li><li>Setting up .env for their specific needs as well eg MYSQL_*</li></ul><p>For the Database to use their settings I have to edit<code>config/database.php</code></p><pre><code>&lt;?php<p>return [</p><pre><code>'fetch' =&amp;gt; PDO::FETCH_CLASS,
'default' =&amp;gt; env('DB_CONNECTION', 'mysql'),
'connections' =&amp;gt; [
'mysql' =&amp;gt; [
'driver' =&amp;gt; 'mysql',
'host' =&amp;gt; env('DB_HOST', 'localhost'),
'database' =&amp;gt; env('DB_DATABASE', env('TEST_ENV_NUMBER')),
'username' =&amp;gt; env('DB_USERNAME', env('MYSQL_USER')),
'password' =&amp;gt; env('DB_PASSWORD', env('MYSQL_PASSWORD')),
'charset' =&amp;gt; 'utf8',
'collation' =&amp;gt; 'utf8_unicode_ci',
'prefix' =&amp;gt; '',
'strict' =&amp;gt; false,
],
],
.......</code></pre><p>];</p><p/></pre><p>Adding</p></p><pre><code>env('DB_PASSWORD', env('MYSQL_PASSWORD')),
env('DB_USERNAME', env('MYSQL_USER')),
env('DB_DATABASE', env('TEST_ENV_NUMBER')),</code></pre><p>So we default to theirs if ours is not there. Finally when we run the test I set the db to the name they want</p><pre><code>DB_DATABASE=test phpunit</code></pre><h2 id="envoy-deploy">Envoy Deploy</h2><p>After it passes I can use Envoy to deploy it.</p><p>The Envoy scripts are not on Forge but use to be so a lot of the naming matches.</p><p>Under the Codeship Deployment page I set</p><pre><code>composer global require "laravel/envoy=~1.0" &amp;&amp; /home/rof/.composer/vendor/bin/envoy run deploy_dev</code></pre><p>In that script do what ever you need to make this thing deploy for example.</p><pre><code>@servers(['dev' => 'forge@foo.com'])<p>@task(&lsquo;deploy_dev&rsquo;, [&lsquo;on&rsquo; => &lsquo;dev&rsquo;])
cd /home/forge/app
git reset &ndash;hard HEAD
git pull origin dev
composer config -g github-oauth.github.com foo
rm -rf vendor
composer install
composer dump-autoload
php artisan migrate:refresh &ndash;seed
bower install
@endtask</p><p/></pre><p>We do not do this on Prod. Someone with proper permissions will run Envoy locally once the tests are passing.</p></p><p><strong>UPDATE</strong></p><p>Easier copy paste</p><pre><code># Set php version through phpenv. 5.3, 5.4 and 5.5 available
phpenv local 5.5
# Install dependencies through Composer
composer config -g github-oauth.github.com foo
touch .env
echo "APP_ENV='testing'" >> .env
echo "MYSQL_TESTING_URL='localhost'" >> .env
echo "MYSQL_TESTING_URL='localhost'" >> .env
echo "APP_KEY=foo" >> .env
echo "CACHE_DRIVER=file" >> .env
echo "SESSION_DRIVER=file" >> .env
echo "QUEUE_DRIVER=sync" >> .env
echo "MAIL_DRIVER=smtp" >> .env
echo "MAIL_HOST=smtp.mailgun.org" >> .env
echo "MAIL_PORT=2525" >> .env
echo "MAIL_USERNAME=postmaster@email.foo.io" >> .env
echo "MAIL_PASSWORD=foo" >> .env
echo "MAIL_ENCRYPTION=true" >> .env
echo "STRIPE_API_SECRET='foo'" >> .env
echo "STRIPE_PUBLIC='foo'" >> .env
composer install --dev</code></pre></description><tags>laravel, testing, phpunit, php, ci, codeship</tags></item><item><title>Easily Create Fixture Data from Remote Services and Refresh Mock Data</title><link>https://alfrednutile.info/posts/145/</link><pubDate>Wed, 27 May 2015 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/145/</guid><description><p><strong>Oops Codeship and Laravel is<a href="https://goo.gl/k62TEB">here</a></strong></p><h1 id="easily-create-fixture-data-from-remote-services-and-refresh-mock-data">Easily Create Fixture Data from Remote Services and Refresh Mock Data</h1><p>We have integration tests that hit remote apis like Github, S3, DynomoDB, our own APIs etc and we do not want to hit those during out tests but we also want to make sure we have the real data. So when one of those APIs change then our mock data can be refreshed to see if our systems really work with it.</p><p>Using Laravel&rsquo;s new integration tests, though this works with any framework, we will swap out these Service classes with a Wrapper class ONLY if we have a matching file. This allows us to delete those files and get another one on the fly.</p><h2 id="lets-start-with-the-controller">Lets start with the Controller</h2><p>This simple Controller will talk to a Repo. Imagine the repo talking to Dynamodb or GithubApi, database etc.</p><pre><code>&lt;?php<p>namespace App\Http\Controllers;</p><p>use App\ExampleRepo;
use Illuminate\Support\Facades\Response;</p><p>class ExampleController extends Controller
{</p><pre><code>public function mocking(ExampleRepo $exampleRepo)
{
return Response::json(&amp;quot;You are here &amp;quot; . $exampleRepo-&amp;gt;get());
}</code></pre><p>}</code></pre><p>So thanks to the dependency injection system; and the use of the Reflection Class,<code>ExampleRepo</code> get constructed as well.</p></p><h2 id="the-tests">The Tests</h2><p>First lets look at a normal test no mock</p><pre><code>&lt;?php<p>use Illuminate\Foundation\Testing\WithoutMiddleware;
use Illuminate\Foundation\Testing\DatabaseTransactions;</p><p>use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\File;
use Mockery as m;</p><p>class ExampleTest extends TestCase
{
public function testDefault()
{
$this->get('/mocking')->see("You are here foo");
}
}</code></pre><p>Pretty simple. But not lets…</p></p><h2 id="swap-things-out">Swap Things Out</h2><p>Here we add an example of replacing the default instance<code>App</code> would make with our own Wrapper</p><pre><code>&lt;?php<p>use Illuminate\Foundation\Testing\WithoutMiddleware;
use Illuminate\Foundation\Testing\DatabaseTransactions;</p><p>use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\File;
use Mockery as m;</p><p>class ExampleTest extends TestCase
{
public function testDefault()
{
$this->get('/mocking')->see("You are here foo");
}</p><pre><code>public function testMocking()
{
$mock = m::mock('App\ExampleRepo');
$mock-&amp;gt;shouldReceive('get')-&amp;gt;once()-&amp;gt;andReturn('bar');
App::instance('App\ExampleRepo', $mock);
$this-&amp;gt;get('/mocking')-&amp;gt;see(&amp;quot;You are here bar&amp;quot;);
}</code></pre><p>}</p><p/></pre><p><code>testMocking</code> will now return bar!</p></p><h2 id="making-fixtures-on-the-fly">Making Fixtures on the Fly</h2><p>Same results BUT we hit my wrapper not the real services. But here is where I think it gets even better. I can return fixture data BUT at the same time I can not worry about returning stale fixture data eg the apis have changed but my fixtures have not. All of this without having my test code wrapped into the app code.</p><p>This will look for the output of a route. That Controller and Repo we will show in a moment</p><pre><code> public function testMakeFixture()
{
$wrapper = App::make('App\ExampleRepoWrapper');
App::instance('App\ExampleRepo', $wrapper);<pre><code> $this-&amp;gt;get('/mocking')-&amp;gt;see(&amp;quot;You are here foo&amp;quot;);
}</code></pre><p/></pre><p>This test has a wrapper which extends the repo</p></p><pre><code>&lt;?php
namespace App;
use Illuminate\Support\Facades\File;
class ExampleRepoWrapper extends ExampleRepo
{
public function get()
{
if(File::exists(base_path('tests/fixtures/foo.json')))
{
$content = File::get(base_path('tests/fixtures/foo.json'));
return json_decode($content, true);
}
$results = parent::get();
if(!File::exists(base_path('tests/fixtures/foo.json')))
{
$content = json_encode($results, JSON_PRETTY_PRINT);
File::put(base_path('tests/fixtures/foo.json'), $content);
}
return $results;
}
}</code></pre><p>So now the Controller will talk to the Wrapper instead which will look for a file<code>(NOTE: You can easily pass in $id or $name to make the fixtures unique)</code></p><p>So now when the Controller hits our Wrapper it goes right to the real<code>ExampleRepo</code> (seen below)<strong>if there is no fixture file</strong> and then the Wrapper kicks in to make the file (as seen in the above class).</p><pre><code>&lt;?php namespace App;<p>class ExampleRepo
{</p><pre><code>protected $results;
public function get()
{
$this-&amp;gt;results = 'foo';
return $this-&amp;gt;results;
}
/**
* @return mixed
*/
public function getResults()
{
return $this-&amp;gt;results;
}</code></pre><p>}</code></pre><p>That is it you can do integration testing on your APIs and not hit external services or even databases.</p></p><h2 id="force-full-integration">Force Full Integration</h2><p>Sometimes you want to hit the external resources. This can be part of a weekly or daily test to make sure you app is working with all the external APIs. You can do this by deleting all the fixtures before running that test.</p><p>So you can setup a provider like this</p><pre><code>
class ExampleProvider extends ServiceProvider
{<p>public function register()
{
if(App::environment() == &lsquo;testing&rsquo; and env(&lsquo;FULL_INTEGRATION&rsquo;) != &lsquo;true&rsquo;)
{
$this->app->bind(&lsquo;App\ExampleRepo&rsquo;, &lsquo;App\ExampleRepoWrapper&rsquo;);<br>
} else {<br>
$this->app->bind(&lsquo;App\ExampleRepo&rsquo;, &lsquo;App\ExampleRepo&rsquo;);
}</p><p>}</p><p>}</p><p>** UPDATE **</p><p>Another good idea, by<a href="https://twitter.com/n_kirschbaum">Nathan Kirschbaum</a>, is to set the<code>FULL_INTEGRATION</code> setting by the user that is logged in.</p><p/></pre><h2 id="cons">Cons</h2></p><p>One is UI testing. Prior to this I would make wrappers as needed to then take over if say<code>APP_MOCK=true</code>. Then I could mock even on Behat testing or the UI. But that meant a lot of Providers and alot of mixing of testing and code. But it worked and ran well on services like CodeShip and locally. If you Behat/Acceptance tests are hitting the API or UI it would be nice to fake all the external responses. Though now with the above the API testing is easy. The UI (when there is javascript) not so easy :(</p><p>Since we are using<code>App::instance</code> we did not need to register a Provider Class. But to make the UI con a non issue you can go that far to register a ServiceProvider</p><pre><code>
class ExampleProvider extends ServiceProvider
{<p>public function register()
{
if(App::environment() == &lsquo;testing&rsquo;
{
$this->app->bind(&lsquo;App\ExampleRepo&rsquo;, &lsquo;App\ExampleRepoWrapper&rsquo;);<br>
} else {<br>
$this->app->bind(&lsquo;App\ExampleRepo&rsquo;, &lsquo;App\ExampleRepo&rsquo;);
}</p><p>}</p><p>}</p><p/></pre><p>Then register as normal in your config/app.php . This can be kinda tedious but would produce the same results.</p></p><p>Great book on the topic<a href="https://leanpub.com/laravel-testing-decoded">Laravel Testing Decoded</a></p><p><img src="https://s3.amazonaws.com/titlepages.leanpub.com/laravel-testing-decoded/large?1425536214" alt="decoded"/></description><tags>testing, laravel, php, phpunit, integration</tags></item><item><title>Timing PHPUnit Tests</title><link>https://alfrednutile.info/posts/127/</link><pubDate>Wed, 31 Dec 2014 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/127/</guid><description><p>Maybe there is a better way to do this? But using this article<a href="https://fatalfailure.wordpress.com/2011/08/22/detecting-slow-tests-with-phpunit/">https://fatalfailure.wordpress.com/2011/08/22/detecting-slow-tests-with-phpunit/</a> I was able to find a hanging test.</p><h1 id="setup">Setup</h1><p>I already have an xml file at the root of my project so I added to that that listener.</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;phpunit backupGlobals="false"
backupStaticAttributes="false"
bootstrap="tests/bootstrap.php"
colors="true"
convertErrorsToExceptions="true"
convertNoticesToExceptions="true"
convertWarningsToExceptions="true"
processIsolation="false"
stopOnFailure="true"
syntaxCheck="false"
>
&lt;listeners>
&lt;listener file="./app/tests/listeners/TestTimesListener.php" />
&lt;/listeners>
&lt;testsuites>
&lt;testsuite name="Application Test Suite">
&lt;directory>./app/tests/BehatEditor/Tests&lt;/directory>
&lt;directory>./app/tests/TheHub/Tests&lt;/directory>
&lt;exclude>./app/tests/BehatEditor/Tests/Migrations&lt;/exclude>
&lt;exclude>./app/tests/DMPIntegration&lt;/exclude>
&lt;/testsuite>
&lt;/testsuites>
&lt;/phpunit></code></pre><p>the lines are</p><pre><code> &lt;listeners>
&lt;listener file="./app/tests/listeners/TestTimesListener.php" />
&lt;/listeners></code></pre><p>That I added.</p><p>Then that file I ended up with this</p><pre><code>&lt;?php<p>class PHPUnitTestListener implements PHPUnit_Framework_TestListener {
private $time;
private $timeLimit = 0;</p><pre><code>public function startTest(PHPUnit_Framework_Test $test) {
$this-&amp;gt;time = time();
}
public function endTest(PHPUnit_Framework_Test $test, $time) {
$current = time();
$took = $current - $this-&amp;gt;time;
if($took &amp;gt; $this-&amp;gt;timeLimit ) {
echo &amp;quot;\nName: &amp;quot;.$test-&amp;gt;getName().&amp;quot; took &amp;quot;.$took . &amp;quot; second(s) (from: $this-&amp;gt;time, to: $current)\n&amp;quot;;
}
}
public function addError(PHPUnit_Framework_Test $test, Exception $e, $time) {
}
public function addFailure(PHPUnit_Framework_Test $test, PHPUnit_Framework_AssertionFailedError $e, $time) {
}
public function addIncompleteTest(PHPUnit_Framework_Test $test, Exception $e, $time){
}
public function addSkippedTest(PHPUnit_Framework_Test $test, Exception $e, $time) {
}
public function startTestSuite(PHPUnit_Framework_TestSuite $suite) {
}
public function endTestSuite(PHPUnit_Framework_TestSuite $suite) {
}
/**
* Risky test.
*
* @param PHPUnit_Framework_Test $test
* @param Exception $e
* @param float $time
* @since Method available since Release 4.0.0
*/
public function addRiskyTest(PHPUnit_Framework_Test $test, Exception $e, $time)
{
// TODO: Implement addRiskyTest() method.
}</code></pre><p>}</code></pre><p>Right now I am only using startTest and endTest.</p></p><p>Finally all my tests have a TestCase class they share so in there I ended up with</p><pre><code>&lt;?php<p>use Faker\Factory as Faker;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Mockery as m;</p><p>class TestCase extends Illuminate\Foundation\Testing\TestCase {</p><pre><code>public function setUp()
{
parent::setUp();
$this-&amp;gt;listener = new PHPUnitTestListener();
$this-&amp;gt;faker = Faker::create();
$this-&amp;gt;prepareForTests();
$this-&amp;gt;listener-&amp;gt;startTest($this);
}
public function tearDown()
{
$this-&amp;gt;listener-&amp;gt;endTest($this, time());
parent::tearDown();
}</code></pre><p/></pre><p>Overall it is pretty simple once the other post pointed it out. Now to use all the other listeners.</p></p></description><tags>php, phpunit, testing</tags></item><item><title>PHP quick fixture data for phpunit testing</title><link>https://alfrednutile.info/posts/117/</link><pubDate>Thu, 20 Nov 2014 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/117/</guid><description><p>You can use VCR or other libraries to make fixture data. But sometimes you can just make the request and save the results using this technique. From then on you mock and return the data.</p><h1 id="get-the-data">Get the data.</h1><p>In this example I had a Client that would get data and return it for import. I was testing out the class that would take this data and import it and do other things. So I make my phpunit test methods of that class (not the Client it is fully tested)</p><pre><code>
/**
* @test
*/
public function should_get_data_to_import()
{
//Load up the client I will later mock, but to get some data to mock
$client = new Client();
//Get the results (api return json)
$results = $client->getData();
//Get the yaml library I am using to covert it to Yaml
$yaml = new Yaml();
//Convert it to Yaml from Array
$results_yml = $yaml->dump($results);
//Save it for now
file_put_contents('/tmp/data.yml', $results_yml);
}<p/></pre><p>Once that is done I copy that data.yml file to fixtures/data.yml which is in the tests folder. Here is a quick look at the folders.</p></p><pre><code>tests
tests/fixtures
// @NOTE this is the file we are using for the test example above
tests/NameSpace/Tests/ClassTest.php</code></pre><p>Finally I rewrite that same test method as</p><pre><code>/**
* @test
*/
public function should_get_data_to_import()
{
$yaml = new Yaml();
$fixture = $yaml->parse(__DIR__ . '/../fixtures/data.yml');
$client = m::mock();
$client->shouldReceive('getData')->andReturn($fixture);
$classTesting new ClassTest($client); //we inject the mock into it
$classTesting->importData();
$this->assertCount(100, $classTesting->getDataImported());
}</code></pre><p>The client in this case if a fully tested standalone client so I am not testing it. Just my use of it to migrate data.</p></description><tags>php, phpunit, testing</tags></item><item><title>Speeding up PHPunit tests and Behat in Laravel for Database refreshes</title><link>https://alfrednutile.info/posts/112/</link><pubDate>Thu, 06 Nov 2014 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/112/</guid><description><p>This<a href="http://www.chrisduell.com/blog/development/speeding-up-unit-tests-in-php/">article</a> covers some good tips on this. Ideally you do not hit the database in unit tests but sometimes you do. Also in behat it hits the db all the time since it is at the Acceptance level.</p><h1 id="sqlite">Sqlite</h1><p>It is a great database and works. We easily can use it on running tests. When seeding the db I have my main seeding class doing this</p><pre><code>&lt;?php<p>use Illuminate\Database\Seeder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Config;
use Illuminate\Support\Facades\DB;</p><p>class DatabaseSeeder extends Seeder {</p><pre><code>/**
* Run the database seeds.
*
* @return void
*/
public function run()
{
Model::unguard();
if(App::environment() != 'testing') {
DB::statement('SET FOREIGN_KEY_CHECKS=0;');
}
$this-&amp;gt;call('AppTableSeeder');
$this-&amp;gt;call('ParentRequestExample');
$this-&amp;gt;call('ProductionSeeder');
if(App::environment() != 'testing') {
DB::statement('SET FOREIGN_KEY_CHECKS=1;');
}
}</code></pre><p>}</p><p/></pre><p>Since sqlite does not like this we skip it for it but not for production etc.</p></p><p>Second my config/testing/database.php looks like this (as noted in the article)</p><pre><code>&lt;?php<p>return [</p><pre><code>'default' =&amp;gt; 'sqlite',
'connections' =&amp;gt; [
'mysql' =&amp;gt; [
'driver' =&amp;gt; 'mysql',
'host' =&amp;gt; $_ENV['DB_URL'],
'database' =&amp;gt; $_ENV['DB_NAME'],
'username' =&amp;gt; $_ENV['MYSQL_USER'],
'password' =&amp;gt; $_ENV['MYSQL_PASSWORD'],
'charset' =&amp;gt; 'utf8',
'collation' =&amp;gt; 'utf8_unicode_ci',
'prefix' =&amp;gt; '',
],
'pgsql' =&amp;gt; [
'driver' =&amp;gt; 'pgsql',
'host' =&amp;gt; 'localhost',
'database' =&amp;gt; 'homestead',
'username' =&amp;gt; 'homestead',
'password' =&amp;gt; 'secret',
'charset' =&amp;gt; 'utf8',
'prefix' =&amp;gt; '',
'schema' =&amp;gt; 'public',
],
'setup' =&amp;gt; array(
'driver' =&amp;gt; 'sqlite',
'database' =&amp;gt; __DIR__.'/../../database/stubdb.sqlite',
'prefix' =&amp;gt; '',
),
'sqlite' =&amp;gt; array(
'driver' =&amp;gt; 'sqlite',
'database' =&amp;gt; __DIR__ . '/../../database/testing.sqlite',
'prefix' =&amp;gt; '',
),
],</code></pre><p>];</code></pre><p>Which makes the below seeding command to setup the stub db work</p></p><pre><code>php artisan migrate:refresh --seed --database="setup" --env="testing"</code></pre><h1 id="phpunit">PHPUnit</h1><p>What I ended up with is a base TestCase like this</p><pre><code>
public function setUp()
{
parent::setUp();
$this->faker = Faker::create();
$this->prepareForTests();
}<pre><code>private function prepareForTests()
{
if(!file_exists(base_path() . '/app/database/testing.sqlite'))
{
$this-&amp;gt;refreshDb();
}
}
public function refreshDb()
{
copy(base_path() . '/app/database/stubdb.sqlite', base_path() . '/app/database/testing.sqlite');
}</code></pre><p/></pre><p>And with any new migrations I run this command</p></p><pre><code>php artisan migrate:refresh --seed --database="setup" --env="testing"</code></pre><p>That file is kept in git since it is just seed data. If there are any conflicts just rm and start over. Testing.sqlite is not kept in git.</p><p>#Behat</p><p>Behat is the same idea. In the main FeatureContext file I have</p><pre><code>
/**
* @Given /^I reseed the database$/
*/
public function iReseedTheDatabase()
{
try
{
dd(getenv('APP_ENV'));
//exec("php artisan migrate:refresh --seed");
copy(__DIR__ . '/../../../../database/stubdb.sqlite', __DIR__ . '/../../../../database/testing.sqlite');
}
catch(\Exception $e)
{
throw new \Exception(sprintf("Error seeding the database %s", $e->getMessage()));
}
}</code></pre><p>So as we test the ui or api we can reload the data.</p><p>#Behat / Laravel</p><p>This package<a href="https://github.com/GuilhermeGuitte/behat-laravel">https://github.com/GuilhermeGuitte/behat-laravel</a></p><p>This integrates behat into artisan command line helping with environment settings for behat.</p></description><tags>laravel, php, behat, phpunit</tags></item><item><title>Quick Gulp file to run php-unit tests</title><link>https://alfrednutile.info/posts/85/</link><pubDate>Sun, 25 May 2014 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/85/</guid><description><p><strong>MUCH BETTER WAY<a href="https://gist.github.com/laracasts/8659865">HERE</a></strong></p><hr><p>This is setup for Laravel but can work for any app. Most of this is due to the great<a href="https://laracasts.com/lessons/gulp-this">Laracasts on Gulp</a></p><p>Download and setup gulp</p><p>First make a package.json file in the root of your app and just put curly brackets in it.</p><pre><code>touch package.json
vim package.json</code></pre><pre><code>//package.json
{<p>}</code></pre><p>Then run the needed node commands</p></p><pre><code>npm install -g gulp
npm install gulp --save-dev
npm install gulp-notify --save-dev
npm install gulp-phpunit --save-dev</code></pre><p>Now the package.json should look like this thanks to the save switch.</p><pre><code>{
"devDependencies": {
"gulp": "^3.6.2",
"gulp-phpunit": "^0.5.3",
"gulp-notify": "^1.3.0"
}
}</code></pre><p>Now to setup the gulpfile, again in the root of your app</p><pre><code>//gulpfile.js
var phpunit = require('gulp-phpunit');
var gulp = require('gulp'),
notify = require('gulp-notify'),
phpunit = require('gulp-phpunit');
gulp.task('phpunit', function() {
var options = {debug: false, notify: true};
gulp.src('app/tests/*.php')
.pipe(phpunit('', options))
.on('error', notify.onError({
title: "Failed Tests!",
message: "Error(s) occurred during testing..."
}));
});
gulp.task('default', function(){
gulp.run('phpunit');
gulp.watch('app/**/*.php', function(){
gulp.run('phpunit');
});
});</code></pre><p>Basically we are saying watch the app folder recursively for file changes to files ending in php then run all the tests in app/tests/*.php.</p><p>Finally run gulp at the command line and it will run keeping an eye on changes.</p><pre><code>gulp</code></pre><p>That is it. From here you will get typically phpunit output as you work BUT also a notice if you break something.</p></description><tags>gulp, phpunit, laravel</tags></item><item><title>Guard, Laravel and phpunit</title><link>https://alfrednutile.info/posts/51/</link><pubDate>Wed, 05 Feb 2014 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/51/</guid><description><p>If you already have rvm install this should be easy. Otherwise google that pain.</p><p>I set my rvm to ruby 2.0 but not sure if needed</p><div class="code"><p>rvm --default use 2.0</p></div><p><a href="http://rvm.io/rubies/default" target="_blank">http://rvm.io/rubies/default</a></p><p>Then I made a Gemfile in the root folder and add this content</p><script src="https://gist.github.com/alnutile/4ce81981e7bfe298de4e.js"/><p>and run bundle install</p><p>After that was in place I ran guard init to get going and then pasted this code into the Guard file it made.</p><script src="https://gist.github.com/alnutile/8831791.js"/><p>So now my root folder has a guard file and it is looking for changes both in app/tests and app/* If the change happens in app/* other than tests it looks for the related *Test.php for that Controller or Model etc It also pops up a notification so you can see all is green or red as you work.</p><p>&nbsp;</p><p>&nbsp;</p><p>Now you are finally ready to run guard&nbsp;</p><p>bundle exe guard&nbsp;</p><p>and that should start up guard</p><p>&nbsp;</p></description><tags>phpunit</tags></item></channel></rss>