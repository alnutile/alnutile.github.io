<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>4.3 on Alfred Nutile</title><link>https://alfrednutile.info/tags/4.3/</link><description>Recent content in 4.3 on Alfred Nutile</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 10 Sep 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://alfrednutile.info/tags/4.3/index.xml" rel="self" type="application/rss+xml"/><item><title>Multi Threaded Queue Processing</title><link>https://alfrednutile.info/posts/106/</link><pubDate>Wed, 10 Sep 2014 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/106/</guid><description><p>I needed a way to run a bunch of jobs in parallel and I am use to using the Symfony Process Component for that.</p><p>So this post will show how I did this in Laravel 4.3 via the Queue so I can remember next time.</p><p>What will come out of this is a workflow as seen here</p><div markdown=0><img src="ttps://dl.dropboxusercontent.com/s/url0i1ibk40u5o7/Screenshot%202014-09-10%2007.59.23.png?dl=" width="0"/><p>We will create two Artisan Commands. This allows us to use Symfony Process to run numerous<strong>console commands</strong> in the background.</p><p>I will not go over how to add a job to the queue there is plenty on that. I will show the class I used for the Queue and it&rsquo;s attributes.</p><pre><code>{
"job":"Foo\\\\Reporting\\\\RequestsCommandQueueRunner",
"data":{
"results_uuid":"4a13aaee-4289-4f95-afe5-ea5abaaed869"
}
}</code></pre><p>This gets pushed into the Queue. It is the &ldquo;Parent&rdquo; that will run x number of children commands. The x is defined in my .env.local.php or .env.production.php files. This way I can increase or decrease the number of threads it will run as needed.</p><p>The results_uuid is the data I need to get the children. In this case the children have that uuid in their table as belongsTo that parent.</p><h2 id="requestscommandqueuerunner">RequestsCommandQueueRunner</h2><p>This Artisan command is quite simple</p><pre><code>&lt;?php<p>#app/Foo/RequestsCommandQueueRunner.php</p><p>namespace Foo\Reporting;</p><p>use Foo\Models\ReportingOverviewBatchRequestJob;
use Foo\QueueServices\QueueInterface;</p><p>class RequestsCommandQueueRunner implements QueueInterface {</p><pre><code>protected $job_limit;
protected $results_uuid;
public function __construct()
{
$this-&amp;gt;job_limit = $_ENV['RESULTS_QUEUE_LIMIT'];
}
public function fire($job, $params)
{
$this-&amp;gt;results_uuid = $params['results_uuid'];
exec(&amp;quot;php artisan request:trigger $this-&amp;gt;results_uuid&amp;quot;, $results);
$job-&amp;gt;delete(); //@TODO make delete if all goes well catch error though and fail it
}</code></pre><p>}</code></pre><p>All it does is passes the parent id to the trigger command. Below is the trigger command.</p></p><p>Note too I am not using the job limit yet. Later I will make x number of Queue jobs as I divide the number of children that parent has by the limit set.</p><h2 id="requestsqueuecommand">RequestsQueueCommand</h2><pre><code>&lt;?php namespace Foo\Console;<p>#app/Foo/Console/RequestsQueueCommand.php</p><p>use Foo\Models\ReportingOverviewBatchRequestJob;
use Illuminate\Console\Command;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Process\Process;</p><p>class RequestsQueueCommand extends Command {</p><pre><code>protected $name = 'request:trigger';
protected $run = [];
protected $description = 'Trigger the running of related jobs';
protected $request_uuid;
protected $projects;
/**
* @var \Foo\Models\ReportingOverviewBatchRequestJob
*/
private $reporting_overview_batch_request_jobs;
public function __construct(
ReportingOverviewBatchRequestJob $reporting_overview_batch_request_jobs
)
{
parent::__construct();
$this-&amp;gt;reporting_overview_batch_request_jobs = $reporting_overview_batch_request_jobs;
}
public function fire()
{
$this-&amp;gt;request_uuid = $this-&amp;gt;argument('request_uuid');
$this-&amp;gt;setRelatedProjects();
$this-&amp;gt;setRun();
$this-&amp;gt;runRelatedProjectsCommand();
return &amp;quot;Fired&amp;quot;;
}
protected function getArguments()
{
return array(
array('request_uuid', InputArgument::REQUIRED, 'The uuid of the Request to trigger the jobs for'),
);
}
protected function setRelatedProjects()
{
$projects =
$this-&amp;gt;reporting_overview_batch_request_jobs-&amp;gt;getAllJobsForReportOverviewBatchRequestUuid($this-&amp;gt;request_uuid);
$this-&amp;gt;projects = $projects-&amp;gt;toArray();
return $this-&amp;gt;projects;
}
protected function setRun()
{
foreach($this-&amp;gt;projects as $project)
{
$this-&amp;gt;addToRun($project['id']);
}
}
protected function runRelatedProjectsCommand()
{
foreach($this-&amp;gt;run as $process)
{
$process-&amp;gt;start();
}
while(count($this-&amp;gt;run) &amp;gt; 0)
{
foreach($this-&amp;gt;run as $key =&amp;gt; $process)
{
if(!$process-&amp;gt;isRunning())
{
\Log::info(&amp;quot;Done running process&amp;quot;);
unset($this-&amp;gt;run[$key]);
}
}
}
}
protected function addToRun($project_id)
{
$this-&amp;gt;run[] = new Process(&amp;quot;php artisan request:run $project_id&amp;quot;);
}</code></pre><p>}</p><p/></pre><p>Here is where things get interesting. I begin the work of finding the children Ids then making an array of<strong>console commands</strong> to run using the children id as the argument I pass.</p></p><p>The Process Component allows me to<strong>start them in the background</strong> and then check on them while they are running.</p><p>Now for the command it runs &ldquo;php artisan request:run $project_id&rdquo;</p><h2 id="requestsjobruncommand">RequestsJobRunCommand</h2><p>This is the process that does the long running work. In this case logs into Github, get some info and reports on it.</p><pre><code>&lt;?php namespace Foo\Console;<p>use Foo\Models\ReportingOverviewBatchRequestJob;
use Foo\Services\RequestJobRunService;
use Illuminate\Console\Command;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;</p><p>class RequestsJobRunCommand extends Command {</p><pre><code>protected $name = 'request:run';
protected $description = 'Run the related job';
protected $job_uuid;
/**
* @var RequestJobRunService
*/
private $requestJobRunService;
/**
* Id of the job we will run
* @var
*/
protected $related_job;
public function __construct(RequestJobRunService $requestJobRunService)
{
parent::__construct();
$this-&amp;gt;requestJobRunService = $requestJobRunService;
}
public function fire()
{
$this-&amp;gt;job_uuid = $this-&amp;gt;argument('job_uuid');
$this-&amp;gt;loadTheJobsInfo();
$this-&amp;gt;requestJobRunService-&amp;gt;getGithubApi()-&amp;gt;authenticate();
$this-&amp;gt;getJobsAndCount();
return &amp;quot;Fired&amp;quot;;
}
protected function getJobsAndCount()
{
try {
$tests = $this-&amp;gt;getRelatedTests();
$tests_count = count($tests);
\Log::info(sprintf(&amp;quot;Updating ReportingOverviewRequest with uuid %s&amp;quot;, $this-&amp;gt;job_uuid));
$this-&amp;gt;related_job-&amp;gt;status = 1;
$this-&amp;gt;related_job-&amp;gt;number_of_tests = $tests_count;
$this-&amp;gt;related_job-&amp;gt;save();
} catch(\Exception $e) {
$this-&amp;gt;related_job-&amp;gt;status = 1; // mark done for now though a fail noted in message box
$this-&amp;gt;related_job-&amp;gt;message = $e-&amp;gt;getMessage();
$this-&amp;gt;related_job-&amp;gt;save();
\Log::error(sprintf(&amp;quot;Error processing job %s for request job request parent uuid %s error &amp;quot;, $this-&amp;gt;related_job-&amp;gt;id, $this-&amp;gt;related_job-&amp;gt;reporting_overview_batch_request_id, $e-&amp;gt;getMessage()));
}
}
protected function getRelatedTests()
{
try {
return $this-&amp;gt;requestJobRunService-&amp;gt;getGithubApi()
-&amp;gt;setReponame($this-&amp;gt;related_job-&amp;gt;repo_name)
-&amp;gt;setAccountName($this-&amp;gt;related_job-&amp;gt;account_name)
-&amp;gt;setBranch($this-&amp;gt;related_job-&amp;gt;branch)
-&amp;gt;index($this-&amp;gt;related_job-&amp;gt;folder);
}
catch(\Exception $e)
{
throw new \Exception(&amp;quot;Error getting index of github &amp;quot; . $e-&amp;gt;getMessage());
}
}
protected function loadTheJobsInfo()
{
$this-&amp;gt;related_job = $this-&amp;gt;requestJobRunService-&amp;gt;getReportingOverviewBatchRepository()-&amp;gt;getReportingOverviewBatchRequestJobsModelInterface()
-&amp;gt;findOrFail($this-&amp;gt;job_uuid);
}
protected function getArguments()
{
return array(
array('job_uuid', InputArgument::REQUIRED, 'The uuid of the related request job to run'),
);
}</code></pre><p>}</code></pre><p>There still is some work to do. I have to set the limit so my initial run does not timeout. I also need to clean up some code so that these classes are digging so deep into the other classes.</p></p><p>But this was just to show how to use Symfony Process Component, Laravel Queue, and Laravel Artisan to run a multi threaded task.</p></description><tags>laravel, php, note2self, 4.3</tags></item></channel></rss>