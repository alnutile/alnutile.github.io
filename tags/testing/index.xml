<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>testing on Alfred Nutile</title><link>https://alfrednutile.info/tags/testing/</link><description>Recent content in testing on Alfred Nutile</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 04 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://alfrednutile.info/tags/testing/index.xml" rel="self" type="application/rss+xml"/><item><title>Mocking, Python, Pytest</title><link>https://alfrednutile.info/posts/268/</link><pubDate>Thu, 04 Mar 2021 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/268/</guid><description><p>Ok this is going to be a collection of notes to self.</p><p>This<a href="https://medium.com/@bfortuner/python-unit-testing-with-pytest-and-mock-197499c4623c">post</a> does a good job of summing up some mock patterns with PyTest.</p><p>I then had to mock the Snyk client which depended on the Requests library. I chose not to mock the requests library but the methods in the snyk library.</p><p>The thing was the method I mocked returned the &ldquo;Response&rdquo; object and I wanted to use the<code>json()</code> feature of that object/class to return the results.</p><p>45 minutes later this worked.</p><pre><code> def test_get_week_of_scans(self, mocker):
mocker.patch.object(SnykClient, 'post')
response = Response()
response.status_code = 200
response.reason = "OK"
response.encoding = "utf-8"
results = json.dumps({
"results": [
{
"count": 1989
}
]
}).encode('utf-8')
response._content = results
SnykClient.post.return_value = response
client = SnykReport()
results = client.get_report_for_current_week(
"98873-8ecc-46f0-b077-39322abc4390")
assert results == 1989</code></pre><p>I no longer hit their API and<code>post</code> returns the response I wanted.</p></description><tags>python, testing, mocking, pytest</tags></item><item><title>PHPUnit CodeCoverage</title><link>https://alfrednutile.info/posts/260/</link><pubDate>Wed, 09 Jan 2019 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/260/</guid><description><h1 id="phpunit-codecoverage">PHPUnit CodeCoverage</h1><p><a href="https://phpunit.de/manual/6.5/en/code-coverage-analysis.html">PHPUnit CodeCoverage</a></p><p>There is a ton of information about your code PHPUNit CodeCoverage can provide. At the root just making sure your coverage is at a certain level and if not where is it lacking.</p><p>With it&rsquo;s xml output I use a script found<a href="https://ocramius.github.io/blog/automated-code-coverage-check-for-github-pull-requests-with-travis/">here</a> to check during our TravisCI builds if the code is meeting a required level.</p><p>Here is a gist of that script<a href="https://gist.github.com/alnutile/78e11717d91f2dfce970f8f1aec68469">here</a>
and here is the<code>.travis.yml</code> section snippet that will run the coverage generating test and then review it for percentage of coverage.</p><pre><code>script:
- vendor/bin/phpcs --standard=psr2 app/
- set -e
- vendor/bin/phpunit --coverage-clover clover.xml --stop-on-failure --testsuite=Unit,Feature
- php ./coverage-checker.php clover.xml 70<p/></pre><p>This is what we run in Travis to review the coverage, if it is below<strong>70</strong>% it will fail.</p></p><blockquote><p>If your unit tests cover 100% of your code, you&rsquo;re doing it wrong.
Just my 2 cts. - Fabien Potencier</p></blockquote><h2 id="setting-up">Setting Up</h2><p>This can be tricky you need Xdebug in place else you might get &ldquo;Coverage driver missing&rdquo; errors.</p><p>Once ready you need to update your<code>phpunit.xml</code> here is my example:</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;phpunit
/// left out some area for brevity
&lt;testsuites>
&lt;testsuite name="Unit">
&lt;directory suffix="Test.php">./tests/Unit&lt;/directory>
&lt;/testsuite><pre><code> &amp;lt;testsuite name=&amp;quot;Feature&amp;quot;&amp;gt;
&amp;lt;directory suffix=&amp;quot;Test.php&amp;quot;&amp;gt;./tests/Feature&amp;lt;/directory&amp;gt;
&amp;lt;/testsuite&amp;gt;
&amp;lt;/testsuites&amp;gt;
&amp;lt;filter&amp;gt;
&amp;lt;whitelist processUncoveredFilesFromWhitelist=&amp;quot;true&amp;quot;&amp;gt;
&amp;lt;directory suffix=&amp;quot;.php&amp;quot;&amp;gt;./app&amp;lt;/directory&amp;gt;
&amp;lt;exclude&amp;gt;
&amp;lt;directory suffix=&amp;quot;.php&amp;quot;&amp;gt;app/Http/Controllers/Auth&amp;lt;/directory&amp;gt;
&amp;lt;file&amp;gt;app/Console/Commands/SetupDeploymentCommand.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Console/Kernel.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Kernel.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Providers/AppServiceProvider.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Providers/AuthServiceProvider.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Providers/EventServiceProvider.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Providers/BroadcastServiceProvider.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Providers/RouteServiceProvider.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Controllers/Controller.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Exceptions/Handler.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Middleware/Authenticate.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Middleware/EncryptCookies.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Middleware/RedirectIfAuthenticated.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Middleware/TrimStrings.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Middleware/TrustProxies.php&amp;lt;/file&amp;gt;
&amp;lt;file&amp;gt;app/Http/Middleware/VerifyCsrfToken.php&amp;lt;/file&amp;gt;
&amp;lt;/exclude&amp;gt;
&amp;lt;/whitelist&amp;gt;
&amp;lt;/filter&amp;gt;
/// left out some area for brevity</code></pre><p>&lt;/phpunit></p><p/></pre><p>Above I setup<code>filter</code> to exclude a bunch of Laravel files I do not want to maintain.</p></p><h2 id="running-the-command">Running the Command</h2><pre><code>vendor/bin/phpunit --coverage-clover clover.xml --stop-on-failure --coverage-html=build</code></pre><p>This will output the clover.xml and make a folder called<code>build</code> make sure to include that in your<code>.gitignore</code></p><p>On my Mac, when done, I just type<code>open build/index.html</code> and I go to a page like this</p><p><img src="https://dl.dropboxusercontent.com/s/vnmt5iy909hycid/Screenshot%202019-01-09%2012.02.29.png?dl=0" alt=""/><h2 id="exploring">Exploring</h2><p>As seen above I get a list of all my classes and how the coverage is on each them. It gets even better from here.</p><h3 id="class-level">Class Level</h3><p>So you are wondering why a class is missing coverage? Click on the Class folder and start to dig in.</p><p><img src="https://dl.dropboxusercontent.com/s/ii7yqczoviw0vpz/Screenshot%202019-01-09%2012.22.23.png?dl=0" alt=""/><p>Maybe it finds something you forgot or maybe it is fussing about a bit of code you know you tested?</p><p>In this example it could be either. So I have two main options.</p><h4 id="annotate-the-test">Annotate the test</h4><p>Let&rsquo;s say I have a Controller level test that is testing this:</p><pre><code> /**
* @covers App\Http\Controllers\AdminController::index
*/
public function testWorksAsAdmin()
{
$user = factory(\App\User::class)->states('admin')->create();
$this->be($user);
$this->get("/admin")->assertStatus(200)->assertSee("Show user");
}<pre><code>/**
* @covers App\Http\Controllers\AdminController::index
*/
public function testWorksAsNonAdmin()
{
$user = factory(\App\User::class)-&amp;gt;create();
$this-&amp;gt;be($user);
$this-&amp;gt;get(&amp;quot;/admin&amp;quot;)-&amp;gt;assertStatus(302);
}</code></pre><p/></pre><p>You can see I specifically tell PHPUnit CodeCoverage that this controller tests are testing this area. But I do not let it know about the MiddleWare so I could do:</p></p><pre><code> /**
* @covers App\Http\Controllers\AdminController::index
* @covers App\Http\Controllers\AdminController::__constructor
*/
public function testWorksAsAdmin()
{
$user = factory(\App\User::class)->states('admin')->create();
$this->be($user);
$this->get("/admin")->assertStatus(200)->assertSee("Show user");
}
/**
* @covers App\Http\Controllers\AdminController::index
* @covers App\Http\Controllers\AdminController::__constructor
*/
public function testWorksAsNonAdmin()
{
$user = factory(\App\User::class)->create();
$this->be($user);
$this->get("/admin")->assertStatus(302);
}</code></pre><p>Then run the test command again and:</p><p><img src="https://dl.dropboxusercontent.com/s/gl8m3ompd4s8vw5/Screenshot%202019-01-09%2012.26.43.png?dl=0" alt=""/><h4 id="annotate-the-class">Annotate the Class</h4><p>In the above I could have just done this:</p><pre><code> /**
* @codeCoverageIgnore
*/
public function __construct()
{
$this->middleware('admin_only')->only("index");
}<p/></pre><p>And that is fine, as long as you know that middleware is tested in it’s own area.</p></p><h4 id="exceptions">Exceptions</h4><p>I tend to do try/catch in my controllers to clearly react to an issue and respond to a user&rsquo;s request but this can show in PHPUnit Coverage as a non tested section of code.</p><p>All I need to do is add a test for that.</p><pre><code> /**
* @covers App\Http\Controllers\AdminController::index
* @covers App\Http\Controllers\AdminController::__constructor
* @expectedException \Exception
*/
public function testWorksAsNonAdmin()
{
$user = factory(\App\User::class)->create();
$this->be($user);
$this->get("/admin")->assertStatus(422);
}<p/></pre><h3 id="dashboard">Dashboard</h3></p><p>This is where some other nice info is surfaced about your code.</p><p><img src="https://dl.dropboxusercontent.com/s/9cgvtghsc56iqyk/dashboard_link.png?dl=0" alt=""/><p>Should bring you to this layout</p><p><img src="https://dl.dropboxusercontent.com/s/04vgti8gogembv8/Screenshot%202019-01-09%2012.31.05.png?dl=0" alt=""/><p>The<strong>CRAP</strong> rating is &ldquo;interesting&rdquo; you can read more about it<a href="https://stackoverflow.com/questions/4731774/how-to-read-improve-c-r-a-p-index-calculated-by-php/4731869#4731869">here</a> since I do not fully understand it myself but imo it comes down not to 100% coverage but:</p><ul><li>Keep classes small and focused</li><li>Keep classed down to 1 public method, even Controllers letting other protected/private methods do the work</li><li>Test the class for message in and message out</li></ul><blockquote><p>&ldquo;You don&rsquo;t send messages because you have objects, you have objects because you send messages - Sandi Metz Poodr Book&rdquo;</p></blockquote><h2 id="helpers">Helpers</h2><p>Two other tools to compliment that above</p><h3 id="phpmetrics">PHPMetrics</h3><p>This tool<a href="http://www.phpmetrics.org/">http://www.phpmetrics.org/</a> can easily be setup and run showing more details about your classes and their state of &ldquo;complexity&rdquo; etc.</p><h3 id="larastan">LaraStan</h3><p>This tool<a href="https://github.com/nunomaduro/larastan">https://github.com/nunomaduro/larastan</a> when it does not go overboard in it&rsquo;s reading your code (set it to a low level) can do a good job of finding issues in your code that you did not find in your tests. It runs over your code including exceptions you did not cover in your tests etc. Really does find some interesting things.</p></description><tags>laravel, testing, phpunit</tags></item><item><title>Python3 Fixtures</title><link>https://alfrednutile.info/posts/252/</link><pubDate>Fri, 10 Aug 2018 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/252/</guid><description><p>Just a reminder using pickle I can easily make fixtures for testing.</p><p>When I get results from AWS SDK for example I can just</p><pre><code>import pickle<pre><code>with open(&amp;quot;fixtures/describe_task_defination.pickle&amp;quot;, 'wb') as fixture:
pickle.dump(self.stored_state_to_save, fixture)</code></pre><p/></pre><p>Then when I want to feed it back in my test</p></p><pre><code>import pickle
from unittest import TestCase
from unittest.mock import patch
from unittest import mock
import pickle
from task_image import TaskImage
def getFixture(name):
with open("fixtures/" + name, 'rb') as fixture:
return pickle.load(fixture)
class TestTaskImage(TestCase)
def setUp(self):
self.task_image = TaskImage()
@patch('task_image.TaskImage._getTaskDefinition', return_value=getFixture('describe_task_defination.pickle'))
@patch('task_image.TaskImage._getService', return_value=getFixture('describe_services.pickle'))
def test_gets_service(self, _getService, _getTaskDefinition):
self.results = self.task_image.handle('default', 'cat-teamdocs-production-122')
self.assertEqual('cat-teamdocs:latest', self.results)</code></pre><p>Pretty easy and then I am not hitting the service</p></description><tags>note2self, python3, testing</tags></item><item><title>Dusk Screenshots to S3 of Failing tests</title><link>https://alfrednutile.info/posts/248/</link><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/248/</guid><description><p>I can be really annoying to troubleshoot a failed test in Dusk when using CI systems. What I ended up doing was setting up my project to send these files to S3 on fail.</p><p>Here are the steps</p><h2 id="setup-you-app">Setup You App</h2><p>This is just S3 storage so make sure you have a bucket and a folder in the bucket to write to. Basically for AWS you make an IAM with a key and secret and let it read/write to this folder. Might look like this policy</p><pre><code>{
"Version": "2012-10-17",
"Statement": [
{
"Action": [
"s3:ListBucket"
],
"Resource": [
"arn:aws:s3:::your-bucket"
],
"Effect": "Allow"
},
{
"Action": [
"*"
],
"Resource": [
"arn:aws:s3:::your-bucket/*"
],
"Effect": "Allow"
}
]
}</code></pre><p>or limited it just to the folder<code>screenshots</code></p><pre><code>{
"Version": "2012-10-17",
"Statement": [
{
"Action": [
"s3:ListAllMyBuckets",
"s3:HeadBucket"
],
"Resource": "*",
"Effect": "Allow",
"Sid": "VisualEditor1"
},
{
"Action": [
"s3:ListBucket",
"s3:GetBucketLocation"
],
"Resource": [
"arn:aws:s3:::your-bucket",
"arn:aws:s3:::your-bucket/*"
],
"Effect": "Allow",
"Sid": "VisualEditor0"
},
{
"Action": [
"s3:GetObject"
],
"Resource": [
"arn:aws:s3:::your-bucket/screenshots",
"arn:aws:s3:::your-bucket/screenshots/*"
],
"Effect": "Allow",
"Sid": "VisualEditor2"
}
]
}</code></pre><p>Now in your<code>tests/DuskTestCase.php</code> file add this:</p><pre><code> public function tearDown()
{
if (env("TRAVIS")) {
$files = \File::files(base_path("tests/Browser/screenshots"));<pre><code> if ($files) {
foreach ($files as $file) {
Storage::disk('travis_fails')
-&amp;gt;put($file-&amp;gt;getFileName(), $file-&amp;gt;getContents());
}
}
}
parent::tearDown();
}</code></pre><p/></pre><p>This will run on Travis based tests saving files to the bucket.</p></p><p>I added to my<code>config/filesystems.php</code> file this:</p><pre><code> 'disks' => [
'travis_fails' => [
'driver' => 's3',
'key' => env('AWS_ACCESS_KEY_ID'),
'secret' => env('AWS_SECRET_ACCESS_KEY'),
'region' => "eu-west-1",
'root' => "screenshots",
'bucket' => 'foo-bucket',
'url' => env('AWS_URL'),
],
///</code></pre><p>Now for TravisCI</p><h2 id="setup-travisci">Setup TravisCI</h2><p>Then in Travis under Settings -> Environment Variables we make sure to add our key and secret with the proper key format:</p><pre><code>AWS_SECRET_ACCESS_KEY=foo
AWS_ACCESS_KEY_ID=bar</code></pre><p><img src="https://dl.dropboxusercontent.com/s/nez8f4hz4anmghl/Screenshot%202018-06-26%2009.36.26.png?dl=0" alt=""/><h2 id="now-you-are-ready-to-fail">Now You are Ready to Fail!</h2><p>Ok so on your next fail you will see in your s3 bucket some of those super handy screenshots.</p></description><tags>dusk, laravel, testing, aws</tags></item><item><title>Getting Started with Orchestra Testbench for Laravel Package Development</title><link>https://alfrednutile.info/posts/241/</link><pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/241/</guid><description><p>The goal of this article will allow one to setup a stand alone package working with it&rsquo;s own tests and has access to all of the normal Laravel workflows outside of Laravel. So you can build it using the easier conventions and helpers Laravel offers.</p><p>Since my work will include database usage I will grab both packages:</p><pre><code>composer require --dev "orchestra/testbench:&lt;=3.5" "orchestra/database:v3.5.0"</code></pre><p>I will setup my<code>composer.json</code> after this as such:</p><pre><code> "autoload-dev": {
"psr-4": {
"Tests\\": "tests/"
}
}</code></pre><p>This way my classes will just have the Tests namespace.</p><p>And then add<code>tests/TestCase.php</code></p><pre><code>&lt;?php<p>namespace Tests;</p><p>use Monolog\Formatter\LineFormatter;
use Monolog\Handler\StreamHandler;
use Mockery;
use AlfredNutileInc\HPClient\HubPlannerProvider;</p><p>class TestCase extends \Orchestra\Testbench\TestCase
{</p><pre><code>/**
* Load any providers I am offering
*/
protected function getPackageProviders($app)
{
return
[
HubPlannerProvider::class,
];
}
public function setUp()
{
parent::setUp();
//I can load any local factories if I want to
//$this-&amp;gt;withFactories(__DIR__ . '/../database/factories');
//make the bast path under tests folder
$this-&amp;gt;app-&amp;gt;setBasePath(__DIR__ . '/../');
//Because I use dynamic facades
\File::makeDirectory(base_path(&amp;quot;storage/framework/cache&amp;quot;), 0755, true, true);
//I can deliver routes for testing
//$this-&amp;gt;app['router']-&amp;gt;get('example', function () {
// return view(&amp;quot;testing&amp;quot;);
//})-&amp;gt;name('featured');
//Load a view for testing
//\View::addLocation(__DIR__ . '/../views');
//$this-&amp;gt;loadLaravelMigrations(['--database' =&amp;gt; 'testing']);
//Any migrations I need to bring in
$this-&amp;gt;loadMigrationsFrom([
'--database' =&amp;gt; 'testing',
'--path' =&amp;gt; realpath(__DIR__ . '/migrations')
]);
//$output = $this-&amp;gt;artisan('migrate', ['--database' =&amp;gt; 'testing']);
}
/**
* Setup logging
*/
protected function getEnvironmentSetUp($app)
{
$app-&amp;gt;configureMonologUsing(function ($monolog) {
$path = __DIR__ . &amp;quot;/logs/laravel.log&amp;quot;;
$handler = $handler = new StreamHandler($path, 'debug');
$handler-&amp;gt;setFormatter(tap(new LineFormatter(null, null, true, true), function ($formatter) {
/** @var LineFormatter $formatter */
$formatter-&amp;gt;includeStacktraces();
}));
/** @var \Monolog\Logger $monolog */
$monolog-&amp;gt;pushHandler($handler);
});
//setup db config if needed
//$app['config']-&amp;gt;set('database.default', 'testbench');
//$app['config']-&amp;gt;set('database.connections.testbench', [
// 'driver' =&amp;gt; 'sqlite',
// 'database' =&amp;gt; ':memory:',
// 'prefix' =&amp;gt; '',
//]);
$app['config']-&amp;gt;set('app.debug', env('APP_DEBUG', true));
//Does my pacakge had any default configurations I want to set
//$app['config']-&amp;gt;set('laravel-feature-flag.logging', true);
}</code></pre><p>}</code></pre><p>Also:</p></p><pre><code>composer require --dev "mockery/mockery:0.9.*"</code></pre><p>Since I use this a lot to mock and it does not come with &ldquo;orchestra/testbench&rdquo;</p><p>Now I am ready to run tests.</p><p>Here is a sample on</p><pre><code>&lt;?php<p>namespace Tests\Feature;</p><p>use Tests\TestCase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Foundation\Testing\RefreshDatabase;
use AlfredNutileInc\HPClient\UserFromResource;
use function GuzzleHttp\json_decode;</p><p>class UserFromResourceTest extends TestCase
{</p><pre><code>use UserFromResource;
public function testResultsFromPayload()
{
$users = \File::get(base_path(&amp;quot;tests/fixtures/resources.json&amp;quot;));
$payload = \File::get(base_path(&amp;quot;tests/fixtures/comments_report_limited.json&amp;quot;));
$results = $this-&amp;gt;transformResouceToResourceName(json_decode($payload, true), json_decode($users, true));
$result = array_first($results);
$this-&amp;gt;assertArrayHasKey('user_name', $result);
$this-&amp;gt;assertEquals('Rob Sherali', $result['user_name']);
}</code></pre><p>}</p><p/></pre><p>I can easily use Facades, helpers etc that I am use to from Laravel.
And I can see logs in<code>logs/laravel.log</code></p></p><p>Also I add</p><pre><code> &lt;php>
&lt;env name="APP_ENV" value="testing"/>
&lt;env name="CACHE_DRIVER" value="array"/>
&lt;env name="SESSION_DRIVER" value="array"/>
&lt;env name="QUEUE_DRIVER" value="sync"/>
&lt;env name="MAIL_DRIVER" value="array"/>
&lt;/php></code></pre><p>To my<code>phpunit.xml.dist</code> so it can set defaults as Laravel does.</p></description><tags>laravel, testing, orchestra</tags></item><item><title>Testing Laravel API, Spark with Authentication</title><link>https://alfrednutile.info/posts/231/</link><pubDate>Sun, 04 Feb 2018 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/231/</guid><description><p>Just a reminder to self, if I want to test an API I made and need to pass and<code>api_token</code></p><pre><code>&lt;?php<p>namespace Tests\Feature;</p><p>use Tests\TestCase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Foundation\Testing\RefreshDatabase;
use App\Quote;
use Laravel\Spark\Repositories\TokenRepository;</p><p>class QuoteControllerTest extends TestCase
{</p><pre><code>use RefreshDatabase;
public function testGettingAQuoteUsingToken()
{
$user = factory(\App\User::class)-&amp;gt;create();
$team = factory(\App\Team::class)-&amp;gt;create();
$team-&amp;gt;users()-&amp;gt;attach($user-&amp;gt;id, ['role' =&amp;gt; &amp;quot;member&amp;quot;]);
$quote = factory(\App\Quote::class)-&amp;gt;create([
'team_id' =&amp;gt; $team-&amp;gt;id,
'posted_by' =&amp;gt; $user-&amp;gt;id
]);
$token = new TokenRepository();
$token = $token-&amp;gt;createToken(
$user,
'get_quote',
[]
)-&amp;gt;token;
$this-&amp;gt;json('GET', &amp;quot;/api/teams/{$team-&amp;gt;id}/quotes/random?api_token={$token}&amp;quot;)
-&amp;gt;assertStatus(200)-&amp;gt;assertJson([
'quote' =&amp;gt; $quote-&amp;gt;quote,
'by' =&amp;gt; $quote-&amp;gt;by,
'posted_by' =&amp;gt; [
'email' =&amp;gt; $user-&amp;gt;email,
'name' =&amp;gt; $user-&amp;gt;name,
'avatar' =&amp;gt; $user-&amp;gt;photo_url
]
]);
}</code></pre><p/></pre><p>Also I made a<code>database/factories/TeamFactory.php</code> file:</p></p><pre><code>&lt;?php
use Faker\Generator as Faker;
use App\User;
use App\Team;
$factory->define(Team::class, function (Faker $faker) {
return [
"name" => $faker->word,
"owner_id" => function() {
return factory(User::class)->create()->id;
}
];
});</code></pre><blockquote/></description><tags>laravel, note2self, testing</tags></item><item><title>Laravel, Dusk and Valet</title><link>https://alfrednutile.info/posts/221/</link><pubDate>Thu, 28 Sep 2017 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/221/</guid><description><p>By default I set my<code>phpunit.xml</code> to use<code>test</code> as my database:</p><pre><code> &lt;php>
&lt;env name="APP_ENV" value="testing"/>
&lt;env name="CACHE_DRIVER" value="array"/>
&lt;env name="SESSION_DRIVER" value="array"/>
&lt;env name="MAIL_DRIVER" value="log"/>
&lt;env name="QUEUE_DRIVER" value="sync"/>
&lt;env name="DB_DATABASE" value="test"/> &lt;-- this line here
&lt;/php></code></pre><p>But with<a href="https://laravel.com/docs/5.5/valet">Valet</a> and<a href="https://laravel.com/docs/5.5/dusk">Dusk</a> this led to the browser using my default database and not<code>test</code>
but the PHPUnit test itself was using<code>test</code> so the user I created and logged in as was not available in the browser.</p><p>I tried to set<code>.env.dusk.local</code> and I tried<code>phpuni.dusk.xml</code> none of it worked so I had to remove<code>&lt;env name="DB_DATABASE" value="test"/></code></p><p>This is a bummer and I am sure I am missing something. What this means and my tests reset my database for my local app which ideally it would not since it is really nice to keep state.</p></description><tags>note2self, laravel, testing</tags></item><item><title>Testing a trait with PHPUnit</title><link>https://alfrednutile.info/posts/212/</link><pubDate>Thu, 08 Jun 2017 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/212/</guid><description><p>In an effort to start recording test coverage using<code>vendor/bin/phpunit --coverage-text --coverage-clover=coverage.clover</code> I had some issues with traits being seen.</p><p>I tried numerous approaches my default being just to<code>Use</code> the trait in the test class. I ended up with this as I found some online info about trait testing<a href="http://blog.florianwolters.de/educational/2012/09/20/Testing-Traits-with-PHPUnit/">here</a> that references a now missing post by Sebastian Bergman the maker of PHPUnit</p><pre><code>&lt;?php<p>use Symfony\Component\Yaml\Yaml;</p><p>/**</p><ul><li><p>Test class for {@see PfawsYaml}.
*</p></li><li><p>@covers \PfAws\Traits\PfawsYaml
*/
class PfawsYamlTest extends TestCase
{</p><p>/**</p><ul><li>The object under test.
*</li><li>@var object
*/
protected $traitObject;</li></ul><p>public function setUp()
{
parent::setUp(); // TODO: Change the autogenerated stub
$this->traitObject = $this->createObjectForTrait();
}</p><p>/**</p><ul><li><p><em>Creation Method</em> to create an object for the trait under test.
*</p></li><li><p>@return object The newly created object.
*/
private function createObjectForTrait()
{
$traitName = &lsquo;\PfAws\Traits\PfawsYaml&rsquo;;</p><p>return $this->getObjectForTrait($traitName);
}</p></li></ul><p>/**</p><ul><li><p>coversDefaultClass loadPfawsYaml
*/
public function testLoadPfawsYaml()
{
$path =<strong>DIR</strong> . &lsquo;/fixtures/pfaws.yaml&rsquo;;</p><p>$results = $this->traitObject->loadPfawsYaml(&lsquo;staging&rsquo;, $path);</p><p>$this->assertEquals("bar2", $results->getPfawsYamlEnv(&lsquo;aws_key&rsquo;));</p><p>$this->assertEquals("foo2", $results->getPfawsYamlEnv(&lsquo;aws_secret&rsquo;));</p><p>$this->assertNotNull($this->traitObject->getPfawsyaml());
}</p></li></ul><p>/**</p><ul><li><p>@coversDefaultClass getPfawsYamlEnv
*/
public function testGetPfawsYamlEnv()
{
$path =<strong>DIR</strong> . &lsquo;/fixtures/pfaws.yaml&rsquo;;</p><p>$results = $this->traitObject->loadPfawsYaml(&lsquo;staging&rsquo;, $path);</p><p>$this->assertEquals("bar2", $results->getPfawsYamlEnv(&lsquo;aws_key&rsquo;));</p><p>$this->assertEquals("foo2", $results->getPfawsYamlEnv(&lsquo;aws_secret&rsquo;));
}</p></li></ul><p>/**</p><ul><li><p>@coversDefaultClass getPfawsyaml
*/
public function testGetPfawsyaml()
{
$path =<strong>DIR</strong> . &lsquo;/fixtures/pfaws.yaml&rsquo;;</p><p>$results = $this->traitObject->loadPfawsYaml(&lsquo;staging&rsquo;, $path);</p><p>$this->assertNotNull($results->getPfawsyaml());</p><p>$this->assertNotNull($results);</p><p>$this->assertEquals("bar2", $results->getPfawsYamlEnv(&lsquo;aws_key&rsquo;));</p><p>$this->assertEquals("foo2", $results->getPfawsYamlEnv(&lsquo;aws_secret&rsquo;));
}</p></li></ul><p>/**</p><ul><li><p>@coversDefaultClass setS3
*/
public function testSetS3() {
$path =<strong>DIR</strong> . &lsquo;/fixtures/pfaws.yaml&rsquo;;
$this->traitObject->loadPfawsYaml(&lsquo;staging&rsquo;, $path);
$this->traitObject->setS3();</p><p>$filesystem = \League\Flysystem\AwsS3v3\AwsS3Adapter::class;
$this->assertInstanceOf($filesystem, $this->traitObject->getS3());
}</p></li></ul><p>/**</p><ul><li><p>@coversDefaultClass getPfawsYamlKeyValue
*/
public function testGetPfawsYamlKeyValue() {
$path =<strong>DIR</strong> . &lsquo;/fixtures/pfaws.yaml&rsquo;;
$this->traitObject->loadPfawsYaml(&lsquo;staging&rsquo;, $path)->setS3();</p><p>$app_name = $this->traitObject->getPfawsYamlKeyValue(&lsquo;app_name&rsquo;);
$this->assertEquals(&lsquo;foo&rsquo;, $app_name);
}
}</p></li></ul></li></ul><p/></pre><p>The annotations are for the coverage to know what I am testing.</p></p><p>This area puts the Trait in to an object using a method provided by PHPUnit:</p><pre><code>/**
* *Creation Method* to create an object for the trait under test.
*
* @return object The newly created object.
*/
private function createObjectForTrait()
{
$traitName = '\PfAws\Traits\PfawsYaml';<pre><code>return $this-&amp;gt;getObjectForTrait($traitName);</code></pre><p>}</code></pre></p><p>And then I run<code>vendor/bin/phpunit --coverage-text --coverage-clover=coverage.clover</code> and the coverage was boosted / recognized.</p><p>On a side note adding to my<code>phpunit.xml</code></p><pre><code> &lt;logging>
&lt;log
type="coverage-html"
target="./docs/coverage"
charset="UTF-8"
yui="true"
lowUpperBound="35"
highLowerBound="70"
showUncoveredFiles="true"
/><pre><code> &amp;lt;log
type=&amp;quot;coverage-text&amp;quot;
target=&amp;quot;php://stdout&amp;quot;
lowUpperBound=&amp;quot;35&amp;quot;
highLowerBound=&amp;quot;70&amp;quot;
/&amp;gt;
&amp;lt;/logging&amp;gt;</code></pre><p/></pre><p>Gave me some really nice code coverage information</p></p><p><img src="https://dl.dropboxusercontent.com/s/2hbocuv8qfyv2u9/code_coverage.png?dl=0" alt=""/></description><tags>php, testing, phpunit</tags></item><item><title>Instantiate Request for Testing</title><link>https://alfrednutile.info/posts/206/</link><pubDate>Tue, 28 Feb 2017 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/206/</guid><description><p>When I need to make a request for a test in which the Class is expecting a<code>\Illuminate\Http\Request</code> I can do this for a file based or non file based request.</p><pre><code> /**
* @Then I should be able to upload an image file
*/
public function iShouldBeAbleToUploadAnImageFile()
{
$request = new \Illuminate\Http\Request();
$file = new \Symfony\Component\HttpFoundation\FileBag();
$path = base_path('tests/fixtures/example_profile.jpg');
$originalName = 'example_profile.jpg';
$upload = new \Illuminate\Http\UploadedFile($path, $originalName, null, null, null, true);
$file->set('profile_image', $upload);
$request->files = $file;<pre><code> $this-&amp;gt;repo = new \App\Repositories\ProfileRepository();
$results = $this-&amp;gt;repo-&amp;gt;uploadUserProfileImage($request);
PHPUnit::assertTrue($results, &amp;quot;Repo did not return true&amp;quot;);
PHPUnit::assertTrue(File::exists(public_path('storage/' . $this-&amp;gt;user-&amp;gt;id . '/example_profile.jpg')), &amp;quot;File Not found&amp;quot;);
}</code></pre><p/></pre><p>Or just Mocked</p></p><pre><code> $fixture = File::get(base_path('tests/fixtures/slack_incoming_run_report.json'));
$fixture = json_decode($fixture, true);
//$request = new \Illuminate\Http\Request([], [], $fixture,[], [], [], false);
$request = Mockery::mock(\Illuminate\Http\Request::class);
$request->shouldReceive('all')->andReturn($fixture);
/** @var \App\PlannerSlackReport $report */
$report = new \App\PlannerSlackReport();
$report->handle($request);</code></pre><blockquote/></description><tags>laravel, note2self, php, testing</tags></item><item><title>Contract Testing</title><link>https://alfrednutile.info/posts/182/</link><pubDate>Fri, 27 May 2016 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/182/</guid><description><p>Sometimes we need to make sure external APIs have not changed. Some of those we have control over some of those we do not.</p><p>Either way we can run tests daily, weekly or as needed, outside of our tests we run with every push to Github, that will make sure this API is still delivering what we expect.</p><p>This<a href="https://www.youtube.com/watch?v=NAF7HWW_eJs">video</a> gave me some good tips on this one being to keep your Contract tests outside of your Domain Logic. Secondly to focus on the KEYS and VALUES you care about.</p><h2 id="keys">KEYS</h2><p>Focusing on the ones you care about can make this a ton easier. If I am calling an API and only want to know the ID and TITLE then I am going to make sure those exist and are in the same place every time.</p><p>Here are some results from the Marvel Comics API</p><pre><code>{
"offset": 0,
"limit": 20,
"total": 733,
"count": 20,
"results": [
{
"id": 55699,
"digitalId": 0,
"title": "Spider-Man (2016) #5",
"issueNumber": 5,
"variantDescription": "",
"description": "BLACK CAT makes her move against SPIDER-MAN!!!",
"modified": "2016-04-05T12:46:27-0400",
"isbn": "",
"upc": "75960608314500511",
"diamondCode": "",
"ean": "",</code></pre><p>I just want to make sure &ldquo;results&rdquo; has a record, with ID and TITLE. So I can call this api via PHPUnit on a scheduled basis and make sure it is working if not ping us in Slack.</p><h2 id="values">VALUES</h2><p>Then there are values. Many times these change so I might not focus on the value of the value but the type. Integer, Array, Not-Null, Empty etc. What am I expecting?</p><h2 id="phpunit">PHPUnit</h2><p>With these two things in place we can have a set of PHPUnit tests that can run on a schedule. You can set your phpunit.xml to hit these as separate Suites.</p><pre><code> &lt;testsuites>
&lt;testsuite name="Application Test Suite">
&lt;directory>./tests/&lt;/directory>
&lt;/testsuite>
&lt;testsuite name="Contracts Test Suite">
&lt;directory>./tests/contracts/&lt;/directory>
&lt;/testsuite>
&lt;/testsuites></code></pre><p>And just run those<code>phpunit --testsuite Contracts Test Suite</code></p></description><tags>php, testing</tags></item><item><title>Codeship and Laravel for Continuous Integration</title><link>https://alfrednutile.info/posts/148/</link><pubDate>Sun, 07 Jun 2015 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/148/</guid><description><p>Getting going on Codeship and Laravel is pretty easy.</p><p>Once you setup codeship to work with your github account just pull in your repo and set your Testing scripts as follows. (they have a ui for ENV variables as well)</p><h2 id="codeship-testing-settings-easier-copy-paste-bottom-of-article">Codeship Testing Settings [easier copy paste bottom of article]</h2><p><img src="https://dl.dropboxusercontent.com/s/fh6vv3g5wpqw7ac/codeship1.png?dl=0" alt="codeship"/><p>You can do this in their UI as well. But at this point I am</p><ul><li>Setting up the composer token for any private repos that application might have</li><li>Setting up .env for their specific needs as well eg MYSQL_*</li></ul><p>For the Database to use their settings I have to edit<code>config/database.php</code></p><pre><code>&lt;?php<p>return [</p><pre><code>'fetch' =&amp;gt; PDO::FETCH_CLASS,
'default' =&amp;gt; env('DB_CONNECTION', 'mysql'),
'connections' =&amp;gt; [
'mysql' =&amp;gt; [
'driver' =&amp;gt; 'mysql',
'host' =&amp;gt; env('DB_HOST', 'localhost'),
'database' =&amp;gt; env('DB_DATABASE', env('TEST_ENV_NUMBER')),
'username' =&amp;gt; env('DB_USERNAME', env('MYSQL_USER')),
'password' =&amp;gt; env('DB_PASSWORD', env('MYSQL_PASSWORD')),
'charset' =&amp;gt; 'utf8',
'collation' =&amp;gt; 'utf8_unicode_ci',
'prefix' =&amp;gt; '',
'strict' =&amp;gt; false,
],
],
.......</code></pre><p>];</p><p/></pre><p>Adding</p></p><pre><code>env('DB_PASSWORD', env('MYSQL_PASSWORD')),
env('DB_USERNAME', env('MYSQL_USER')),
env('DB_DATABASE', env('TEST_ENV_NUMBER')),</code></pre><p>So we default to theirs if ours is not there. Finally when we run the test I set the db to the name they want</p><pre><code>DB_DATABASE=test phpunit</code></pre><h2 id="envoy-deploy">Envoy Deploy</h2><p>After it passes I can use Envoy to deploy it.</p><p>The Envoy scripts are not on Forge but use to be so a lot of the naming matches.</p><p>Under the Codeship Deployment page I set</p><pre><code>composer global require "laravel/envoy=~1.0" &amp;&amp; /home/rof/.composer/vendor/bin/envoy run deploy_dev</code></pre><p>In that script do what ever you need to make this thing deploy for example.</p><pre><code>@servers(['dev' => 'forge@foo.com'])<p>@task(&lsquo;deploy_dev&rsquo;, [&lsquo;on&rsquo; => &lsquo;dev&rsquo;])
cd /home/forge/app
git reset &ndash;hard HEAD
git pull origin dev
composer config -g github-oauth.github.com foo
rm -rf vendor
composer install
composer dump-autoload
php artisan migrate:refresh &ndash;seed
bower install
@endtask</p><p/></pre><p>We do not do this on Prod. Someone with proper permissions will run Envoy locally once the tests are passing.</p></p><p><strong>UPDATE</strong></p><p>Easier copy paste</p><pre><code># Set php version through phpenv. 5.3, 5.4 and 5.5 available
phpenv local 5.5
# Install dependencies through Composer
composer config -g github-oauth.github.com foo
touch .env
echo "APP_ENV='testing'" >> .env
echo "MYSQL_TESTING_URL='localhost'" >> .env
echo "MYSQL_TESTING_URL='localhost'" >> .env
echo "APP_KEY=foo" >> .env
echo "CACHE_DRIVER=file" >> .env
echo "SESSION_DRIVER=file" >> .env
echo "QUEUE_DRIVER=sync" >> .env
echo "MAIL_DRIVER=smtp" >> .env
echo "MAIL_HOST=smtp.mailgun.org" >> .env
echo "MAIL_PORT=2525" >> .env
echo "MAIL_USERNAME=postmaster@email.foo.io" >> .env
echo "MAIL_PASSWORD=foo" >> .env
echo "MAIL_ENCRYPTION=true" >> .env
echo "STRIPE_API_SECRET='foo'" >> .env
echo "STRIPE_PUBLIC='foo'" >> .env
composer install --dev</code></pre></description><tags>laravel, testing, phpunit, php, ci, codeship</tags></item><item><title>Easily Create Fixture Data from Remote Services and Refresh Mock Data</title><link>https://alfrednutile.info/posts/145/</link><pubDate>Wed, 27 May 2015 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/145/</guid><description><p><strong>Oops Codeship and Laravel is<a href="https://goo.gl/k62TEB">here</a></strong></p><h1 id="easily-create-fixture-data-from-remote-services-and-refresh-mock-data">Easily Create Fixture Data from Remote Services and Refresh Mock Data</h1><p>We have integration tests that hit remote apis like Github, S3, DynomoDB, our own APIs etc and we do not want to hit those during out tests but we also want to make sure we have the real data. So when one of those APIs change then our mock data can be refreshed to see if our systems really work with it.</p><p>Using Laravel&rsquo;s new integration tests, though this works with any framework, we will swap out these Service classes with a Wrapper class ONLY if we have a matching file. This allows us to delete those files and get another one on the fly.</p><h2 id="lets-start-with-the-controller">Lets start with the Controller</h2><p>This simple Controller will talk to a Repo. Imagine the repo talking to Dynamodb or GithubApi, database etc.</p><pre><code>&lt;?php<p>namespace App\Http\Controllers;</p><p>use App\ExampleRepo;
use Illuminate\Support\Facades\Response;</p><p>class ExampleController extends Controller
{</p><pre><code>public function mocking(ExampleRepo $exampleRepo)
{
return Response::json(&amp;quot;You are here &amp;quot; . $exampleRepo-&amp;gt;get());
}</code></pre><p>}</code></pre><p>So thanks to the dependency injection system; and the use of the Reflection Class,<code>ExampleRepo</code> get constructed as well.</p></p><h2 id="the-tests">The Tests</h2><p>First lets look at a normal test no mock</p><pre><code>&lt;?php<p>use Illuminate\Foundation\Testing\WithoutMiddleware;
use Illuminate\Foundation\Testing\DatabaseTransactions;</p><p>use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\File;
use Mockery as m;</p><p>class ExampleTest extends TestCase
{
public function testDefault()
{
$this->get('/mocking')->see("You are here foo");
}
}</code></pre><p>Pretty simple. But not lets…</p></p><h2 id="swap-things-out">Swap Things Out</h2><p>Here we add an example of replacing the default instance<code>App</code> would make with our own Wrapper</p><pre><code>&lt;?php<p>use Illuminate\Foundation\Testing\WithoutMiddleware;
use Illuminate\Foundation\Testing\DatabaseTransactions;</p><p>use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\File;
use Mockery as m;</p><p>class ExampleTest extends TestCase
{
public function testDefault()
{
$this->get('/mocking')->see("You are here foo");
}</p><pre><code>public function testMocking()
{
$mock = m::mock('App\ExampleRepo');
$mock-&amp;gt;shouldReceive('get')-&amp;gt;once()-&amp;gt;andReturn('bar');
App::instance('App\ExampleRepo', $mock);
$this-&amp;gt;get('/mocking')-&amp;gt;see(&amp;quot;You are here bar&amp;quot;);
}</code></pre><p>}</p><p/></pre><p><code>testMocking</code> will now return bar!</p></p><h2 id="making-fixtures-on-the-fly">Making Fixtures on the Fly</h2><p>Same results BUT we hit my wrapper not the real services. But here is where I think it gets even better. I can return fixture data BUT at the same time I can not worry about returning stale fixture data eg the apis have changed but my fixtures have not. All of this without having my test code wrapped into the app code.</p><p>This will look for the output of a route. That Controller and Repo we will show in a moment</p><pre><code> public function testMakeFixture()
{
$wrapper = App::make('App\ExampleRepoWrapper');
App::instance('App\ExampleRepo', $wrapper);<pre><code> $this-&amp;gt;get('/mocking')-&amp;gt;see(&amp;quot;You are here foo&amp;quot;);
}</code></pre><p/></pre><p>This test has a wrapper which extends the repo</p></p><pre><code>&lt;?php
namespace App;
use Illuminate\Support\Facades\File;
class ExampleRepoWrapper extends ExampleRepo
{
public function get()
{
if(File::exists(base_path('tests/fixtures/foo.json')))
{
$content = File::get(base_path('tests/fixtures/foo.json'));
return json_decode($content, true);
}
$results = parent::get();
if(!File::exists(base_path('tests/fixtures/foo.json')))
{
$content = json_encode($results, JSON_PRETTY_PRINT);
File::put(base_path('tests/fixtures/foo.json'), $content);
}
return $results;
}
}</code></pre><p>So now the Controller will talk to the Wrapper instead which will look for a file<code>(NOTE: You can easily pass in $id or $name to make the fixtures unique)</code></p><p>So now when the Controller hits our Wrapper it goes right to the real<code>ExampleRepo</code> (seen below)<strong>if there is no fixture file</strong> and then the Wrapper kicks in to make the file (as seen in the above class).</p><pre><code>&lt;?php namespace App;<p>class ExampleRepo
{</p><pre><code>protected $results;
public function get()
{
$this-&amp;gt;results = 'foo';
return $this-&amp;gt;results;
}
/**
* @return mixed
*/
public function getResults()
{
return $this-&amp;gt;results;
}</code></pre><p>}</code></pre><p>That is it you can do integration testing on your APIs and not hit external services or even databases.</p></p><h2 id="force-full-integration">Force Full Integration</h2><p>Sometimes you want to hit the external resources. This can be part of a weekly or daily test to make sure you app is working with all the external APIs. You can do this by deleting all the fixtures before running that test.</p><p>So you can setup a provider like this</p><pre><code>
class ExampleProvider extends ServiceProvider
{<p>public function register()
{
if(App::environment() == &lsquo;testing&rsquo; and env(&lsquo;FULL_INTEGRATION&rsquo;) != &lsquo;true&rsquo;)
{
$this->app->bind(&lsquo;App\ExampleRepo&rsquo;, &lsquo;App\ExampleRepoWrapper&rsquo;);<br>
} else {<br>
$this->app->bind(&lsquo;App\ExampleRepo&rsquo;, &lsquo;App\ExampleRepo&rsquo;);
}</p><p>}</p><p>}</p><p>** UPDATE **</p><p>Another good idea, by<a href="https://twitter.com/n_kirschbaum">Nathan Kirschbaum</a>, is to set the<code>FULL_INTEGRATION</code> setting by the user that is logged in.</p><p/></pre><h2 id="cons">Cons</h2></p><p>One is UI testing. Prior to this I would make wrappers as needed to then take over if say<code>APP_MOCK=true</code>. Then I could mock even on Behat testing or the UI. But that meant a lot of Providers and alot of mixing of testing and code. But it worked and ran well on services like CodeShip and locally. If you Behat/Acceptance tests are hitting the API or UI it would be nice to fake all the external responses. Though now with the above the API testing is easy. The UI (when there is javascript) not so easy :(</p><p>Since we are using<code>App::instance</code> we did not need to register a Provider Class. But to make the UI con a non issue you can go that far to register a ServiceProvider</p><pre><code>
class ExampleProvider extends ServiceProvider
{<p>public function register()
{
if(App::environment() == &lsquo;testing&rsquo;
{
$this->app->bind(&lsquo;App\ExampleRepo&rsquo;, &lsquo;App\ExampleRepoWrapper&rsquo;);<br>
} else {<br>
$this->app->bind(&lsquo;App\ExampleRepo&rsquo;, &lsquo;App\ExampleRepo&rsquo;);
}</p><p>}</p><p>}</p><p/></pre><p>Then register as normal in your config/app.php . This can be kinda tedious but would produce the same results.</p></p><p>Great book on the topic<a href="https://leanpub.com/laravel-testing-decoded">Laravel Testing Decoded</a></p><p><img src="https://s3.amazonaws.com/titlepages.leanpub.com/laravel-testing-decoded/large?1425536214" alt="decoded"/></description><tags>testing, laravel, php, phpunit, integration</tags></item><item><title>Timing PHPUnit Tests</title><link>https://alfrednutile.info/posts/127/</link><pubDate>Wed, 31 Dec 2014 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/127/</guid><description><p>Maybe there is a better way to do this? But using this article<a href="https://fatalfailure.wordpress.com/2011/08/22/detecting-slow-tests-with-phpunit/">https://fatalfailure.wordpress.com/2011/08/22/detecting-slow-tests-with-phpunit/</a> I was able to find a hanging test.</p><h1 id="setup">Setup</h1><p>I already have an xml file at the root of my project so I added to that that listener.</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;phpunit backupGlobals="false"
backupStaticAttributes="false"
bootstrap="tests/bootstrap.php"
colors="true"
convertErrorsToExceptions="true"
convertNoticesToExceptions="true"
convertWarningsToExceptions="true"
processIsolation="false"
stopOnFailure="true"
syntaxCheck="false"
>
&lt;listeners>
&lt;listener file="./app/tests/listeners/TestTimesListener.php" />
&lt;/listeners>
&lt;testsuites>
&lt;testsuite name="Application Test Suite">
&lt;directory>./app/tests/BehatEditor/Tests&lt;/directory>
&lt;directory>./app/tests/TheHub/Tests&lt;/directory>
&lt;exclude>./app/tests/BehatEditor/Tests/Migrations&lt;/exclude>
&lt;exclude>./app/tests/DMPIntegration&lt;/exclude>
&lt;/testsuite>
&lt;/testsuites>
&lt;/phpunit></code></pre><p>the lines are</p><pre><code> &lt;listeners>
&lt;listener file="./app/tests/listeners/TestTimesListener.php" />
&lt;/listeners></code></pre><p>That I added.</p><p>Then that file I ended up with this</p><pre><code>&lt;?php<p>class PHPUnitTestListener implements PHPUnit_Framework_TestListener {
private $time;
private $timeLimit = 0;</p><pre><code>public function startTest(PHPUnit_Framework_Test $test) {
$this-&amp;gt;time = time();
}
public function endTest(PHPUnit_Framework_Test $test, $time) {
$current = time();
$took = $current - $this-&amp;gt;time;
if($took &amp;gt; $this-&amp;gt;timeLimit ) {
echo &amp;quot;\nName: &amp;quot;.$test-&amp;gt;getName().&amp;quot; took &amp;quot;.$took . &amp;quot; second(s) (from: $this-&amp;gt;time, to: $current)\n&amp;quot;;
}
}
public function addError(PHPUnit_Framework_Test $test, Exception $e, $time) {
}
public function addFailure(PHPUnit_Framework_Test $test, PHPUnit_Framework_AssertionFailedError $e, $time) {
}
public function addIncompleteTest(PHPUnit_Framework_Test $test, Exception $e, $time){
}
public function addSkippedTest(PHPUnit_Framework_Test $test, Exception $e, $time) {
}
public function startTestSuite(PHPUnit_Framework_TestSuite $suite) {
}
public function endTestSuite(PHPUnit_Framework_TestSuite $suite) {
}
/**
* Risky test.
*
* @param PHPUnit_Framework_Test $test
* @param Exception $e
* @param float $time
* @since Method available since Release 4.0.0
*/
public function addRiskyTest(PHPUnit_Framework_Test $test, Exception $e, $time)
{
// TODO: Implement addRiskyTest() method.
}</code></pre><p>}</code></pre><p>Right now I am only using startTest and endTest.</p></p><p>Finally all my tests have a TestCase class they share so in there I ended up with</p><pre><code>&lt;?php<p>use Faker\Factory as Faker;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Mockery as m;</p><p>class TestCase extends Illuminate\Foundation\Testing\TestCase {</p><pre><code>public function setUp()
{
parent::setUp();
$this-&amp;gt;listener = new PHPUnitTestListener();
$this-&amp;gt;faker = Faker::create();
$this-&amp;gt;prepareForTests();
$this-&amp;gt;listener-&amp;gt;startTest($this);
}
public function tearDown()
{
$this-&amp;gt;listener-&amp;gt;endTest($this, time());
parent::tearDown();
}</code></pre><p/></pre><p>Overall it is pretty simple once the other post pointed it out. Now to use all the other listeners.</p></p></description><tags>php, phpunit, testing</tags></item><item><title>PHP quick fixture data for phpunit testing</title><link>https://alfrednutile.info/posts/117/</link><pubDate>Thu, 20 Nov 2014 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/117/</guid><description><p>You can use VCR or other libraries to make fixture data. But sometimes you can just make the request and save the results using this technique. From then on you mock and return the data.</p><h1 id="get-the-data">Get the data.</h1><p>In this example I had a Client that would get data and return it for import. I was testing out the class that would take this data and import it and do other things. So I make my phpunit test methods of that class (not the Client it is fully tested)</p><pre><code>
/**
* @test
*/
public function should_get_data_to_import()
{
//Load up the client I will later mock, but to get some data to mock
$client = new Client();
//Get the results (api return json)
$results = $client->getData();
//Get the yaml library I am using to covert it to Yaml
$yaml = new Yaml();
//Convert it to Yaml from Array
$results_yml = $yaml->dump($results);
//Save it for now
file_put_contents('/tmp/data.yml', $results_yml);
}<p/></pre><p>Once that is done I copy that data.yml file to fixtures/data.yml which is in the tests folder. Here is a quick look at the folders.</p></p><pre><code>tests
tests/fixtures
// @NOTE this is the file we are using for the test example above
tests/NameSpace/Tests/ClassTest.php</code></pre><p>Finally I rewrite that same test method as</p><pre><code>/**
* @test
*/
public function should_get_data_to_import()
{
$yaml = new Yaml();
$fixture = $yaml->parse(__DIR__ . '/../fixtures/data.yml');
$client = m::mock();
$client->shouldReceive('getData')->andReturn($fixture);
$classTesting new ClassTest($client); //we inject the mock into it
$classTesting->importData();
$this->assertCount(100, $classTesting->getDataImported());
}</code></pre><p>The client in this case if a fully tested standalone client so I am not testing it. Just my use of it to migrate data.</p></description><tags>php, phpunit, testing</tags></item><item><title>Using VCR for PHP API Testing</title><link>https://alfrednutile.info/posts/97/</link><pubDate>Wed, 16 Jul 2014 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/97/</guid><description><p>Testing that your code works against an API can take up lots of un-needed time. With this<a href="https://github.com/php-vcr/php-vcr">php-vcr</a> library you can do ONE real request that saves a fixture file that will automatically be used with each additional requests!</p><p>They have decent docs on setting up but I will walk through them here.</p><p>I will base this off a seed phpunit repo I have<a href="https://github.com/alnutile/base_library_repo">https://github.com/alnutile/base_library_repo</a></p><p>You will need to add to the composer.json the packages for this library</p><pre><code> "require": {
"php": ">=5.4.0",
"ext-curl": "*",
"symfony/process": ">=2.3",
"symfony/event-dispatcher": ">=2.3",
"guzzle/guzzle": "~3.7",
"vlucas/phpdotenv": "1.0.6"
},
"require-dev": {
"phpunit/phpunit": "~3.0",
"mockery/mockery": "dev-master",
"php-vcr/php-vcr": "dev-master",
"php-vcr/phpunit-testlistener-vcr": "dev-master"
}</code></pre><p>I have another post that talks about the dotenv package<a href="http://www.alfrednutile.info/posts/76">here</a></p><p>Then if you test folder make a a fixtures folder. So you layout is</p><pre><code>.
--test
-----fixtures</code></pre><p>And open your phpunit.xml file to add the code to intercept your requests.</p><pre><code>#/phpunit.xml<p>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;phpunit backupGlobals="false"
backupStaticAttributes="false"
bootstrap="test/bootstrap.php"
colors="true"
convertErrorsToExceptions="true"
convertNoticesToExceptions="true"
convertWarningsToExceptions="true"
processIsolation="false"
stopOnFailure="false"
syntaxCheck="false"
>
&lt;listeners>
&lt;listener class="PHPUnit_Util_Log_VCR" file="vendor/php-vcr/phpunit-testlistener-vcr/PHPUnit/Util/Log/VCR.php" />
&lt;/listeners>
&lt;testsuites>
&lt;testsuite name="Application Test Suite">
&lt;directory>test&lt;/directory>
&lt;/testsuite>
&lt;/testsuites>
&lt;/phpunit></code></pre><p>Lastly edit your phpunit bootstrap file to setup VCR</p></p><pre><code>#test/bootstrap.php
&lt;?php
function includeIfExists($file)
{
if (file_exists($file)) {
return include $file;
}
}
if ((!$loader = includeIfExists(__DIR__.'/../vendor/autoload.php')) &amp;&amp; (!$loader = includeIfExists(__DIR__.'/../../../.composer/autoload.php'))) {
die('You must set up the project dependencies, run the following commands:'.PHP_EOL.
'curl -s http://getcomposer.org/installer | php'.PHP_EOL.
'php composer.phar install'.PHP_EOL);
}
\VCR\VCR::configure()->setCassettePath(__DIR__ .'/../test/fixtures');
$loader->add('Foo\SauceLabs', __DIR__);
return $loader;</code></pre><p>Now you are ready to use the API. This repo has a ton of tests using the api<a href="https://github.com/alnutile/saucelabs_client">https://github.com/alnutile/saucelabs_client</a></p><p>You will see in this file for example how it is called in the doc blocks</p><pre><code>#test/SauceLabs/Tests/JobsTest.php
use SauceLabs\Client;
use VCR\VCR;
use SauceLabs\Tests\BaseTest as Base;<p>class JobsTest extends Base {</p><pre><code>protected function tearDown()
{
m::close();
}
/**
* @test
* @@vcr get_jobs
*/
public function get_jobs()
{
$username = $_ENV['USERNAME_KEY'];
VCR::turnOn();
//VCR::insertCassette('authenticate');
VCR::insertCassette('get_jobs');
//Arrange
$sauce_api = new Client();
$sauce_api-&amp;gt;authenticate($username, $_ENV['TOKEN_PASSWORD'], Client::AUTH_HTTP_PASSWORD);
//Act
$response = $sauce_api-&amp;gt;api('jobs')-&amp;gt;getJobs($username);
//Assert
$this-&amp;gt;assertGreaterThan(15, count($response));
// To stop recording requests, eject the cassette
VCR::eject();
// Turn off VCR to stop intercepting requests
VCR::turnOff();
}</code></pre><p/></pre><p>After the first time you run that you will have a new “cassette” in the test/fixtures folder that you can use as needed</p></p><pre><code>#test/fixtures/get_jobs
-
request:
method: GET
url: 'https://saucelabs.com/rest/v1/api-test-user/jobs'
headers:
Host: saucelabs.com
Accept: application/vnd.SauceLabs.beta+json
User-Agent: 'php-github-api (http://github.com/alnutile/saucelabs_client)'
Authorization: 'Basic YmVoYXQtc2VlZDpmYzViNjg4YS1mMjdjLTRjNzMtYTkxNC1lYjVkN2UyY2RmMWU='
Content-Length: '0'
response:
status: 200
headers:
Server: nginx
Date: 'Fri, 11 Jul 2014 11:03:19 GMT'
Content-Type: 'application/json; charset=utf-8'
Transfer-Encoding: chunked
Connection: keep-alive
X-Backend: mix
body: '[{"id": "79bd34f42d584da6ad59c051388134d9"}, {"id": "d75177a863ec4a458c7222813e10ee84"}, {"id": "67591976001c4c5a9522b93281e0e8ef"}, {"id": "ada6876f799d4b589ef0e2c4069c7438"}, {"id": "3e676ac921aa43f5a5628d231ca7115d"}, {"id": "222cdddafb9e4c3fb0722bccc9891a15"}, {"id": "6393dc7ca1ea447eb509b5e1dd6821ac"}, {"id": "789004fc2ec34d0d8e03945759fc25b0"}, {"id": "3331badd2da140d08613a786257d177d"}, {"id": "9437a50a354e4fca8252447b03d21348"}, {"id": "dec07ca1c30e40f4a693de7f7a102eab"}, {"id": "3a1a0fb2d4be4580b00a3e35b86aa6fa"}, {"id": "55de27651bf14c92b901cbd0a62b1603"}, {"id": "7e12ec786ad544008c5f4e3e4340d5a8"}, {"id": "a8edb7ab8a8f408a9b0829cc45ca4563"}, {"id": "b67a4d7187cc4dc8ad661ef7045d15e9"}]'
-
request:
method: GET
url: 'https://saucelabs.com/rest/v1/behat-seed/jobs'
headers:
Host: saucelabs.com
Accept: application/vnd.SauceLabs.beta+json
User-Agent: 'php-github-api (http://github.com/alnutile/saucelabs_client)'
Authorization: 'Basic YmVoYXQdtc2VlZssDpmYzViNjdfasdfg4YS1mMjdrerjLTRjNzMtYTkxNC1l3eYjVkN2UyY2RmMadsfWUj='
Content-Length: '0'
response:
status: 200
headers:
Server: nginx
Date: 'Fri, 11 Jul 2014 13:41:38 GMT'
Content-Type: 'application/json; charset=utf-8'
Transfer-Encoding: chunked
Connection: keep-alive
X-Backend: mix
body: '[{"id": "3a4136e1bb6f4f6b8cae6fbd0bf2e6aa"}, {"id": "1cde7b77e8744ff5b6198489ceffce81"}, {"id": "79bd34f42d584da6ad59c051388134d9"}, {"id": "d75177a863ec4a458c7222813e10ee84"}, {"id": "67591976001c4c5a9522b93281e0e8ef"}, {"id": "ada6876f799d4b589ef0e2c4069c7438"}, {"id": "3e676ac921aa43f5a5628d231ca7115d"}, {"id": "222cdddafb9e4c3fb0722bccc9891a15"}, {"id": "6393dc7ca1ea447eb509b5e1dd6821ac"}, {"id": "789004fc2ec34d0d8e03945759fc25b0"}, {"id": "3331badd2da140d08613a786257d177d"}, {"id": "9437a50a354e4fca8252447b03d21348"}, {"id": "dec07ca1c30e40f4a693de7f7a102eab"}, {"id": "3a1a0fb2d4be4580b00a3e35b86aa6fa"}, {"id": "55de27651bf14c92b901cbd0a62b1603"}, {"id": "7e12ec786ad544008c5f4e3e4340d5a8"}, {"id": "a8edb7ab8a8f408a9b0829cc45ca4563"}, {"id": "b67a4d7187cc4dc8ad661ef7045d15e9"}]'</code></pre><p>That library should be a big help to try it out. You just need a Saucelabs account and make a file in the root of your folder called .env as noted in the README with your username and token for saucelabs and then run bin/phpunit.</p></description><tags>php, api, testing</tags></item><item><title>Saucelabs PHP Client</title><link>https://alfrednutile.info/posts/96/</link><pubDate>Fri, 11 Jul 2014 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/96/</guid><description><p>It is built off of the php-github-api client seen<a href="https://github.com/KnpLabs/php-github-api">here</a> by KnpLabs . They made a really nice client that uses Guzzle and an AbstractionAPI to make it easy to code out different classes around the API endpoints.</p><p>Anyways I have had such a good experience with github one I figured it would be nice to have one for the Saucelabs work I do.</p><p><a href="https://github.com/alnutile/saucelabs_client">https://github.com/alnutile/saucelabs_client</a> more features will be added shortly as it is being used in a couple of decent size projects.</p><p>There are plenty of Tests to show how to use it.</p></description><tags>bdd, testing, php</tags></item><item><title>Mocking drupal database queries</title><link>https://alfrednutile.info/posts/46/</link><pubDate>Fri, 07 Mar 2014 00:00:00 +0000</pubDate><guid>https://alfrednutile.info/posts/46/</guid><description><p><b>formatting issue will update the code examples soon</b></p><p><span style="line-height: 1.6em;">I have a Class I want to test with phpunit but it makes several queries to a drupal database. I rather not bootstrapdrupal just to make sure this Class is returning the results as expected.</span></p><p>For example the SiteClass has a method called index. That method takes the uuid for a user and finds all the sites related to that user. Then using that uuid I have some other non drupal data that relates to it. So my class might look like this</p><div class="code prettify" style="background:#eee;border:1px solid #ccc;padding:5px 10px;"><p>//Foo.php<br/>
public function getSitesAndOtherDataForUser($uuid) {<br/>
$output = db_query(some query here);<br/>
return array('data' => $output)<br/><span style="line-height: 1.6em;">}</span></p></div><p><span style="line-height: 1.6em;">But this is hard to test quickly in phpunit without touching the database. But I do not want to test the database. I know db_query works. I know the database layer works. I just want to verify this class is getting the request, getting information and then passing me back the right data format.</span></p><p><span style="line-height: 1.6em;">One way to do that is to make a Repository class that wraps all your database queries into methods.</span></p><p><span style="line-height: 1.6em;">So the class SiteClass has a constructor that allows the injection of the repository class for example</span></p><div class="code prettify" style="background:#eee;border:1px solid #ccc;padding:5px 10px;"><p><span style="line-height: 1.6em;">//Foo.php<br/>
public function __construct(SiteRepository $repo = null)</span></p><p>{<br/>
$this->repo = ($repo == null) ? new SiteRepository() : $repo;<br/>
}</p></div><p>This then turns the above function into</p><div class="code prettify" style="background:#eee;border:1px solid #ccc;padding:5px 10px;"><p><span style="background-color: rgb(238, 238, 238);">//Foo.php</span><br style="background-color: rgb(238, 238, 238);"/>
public function getSitesAndOtherDataForUser($uuid) {<br/>
$output = $this->repo->getSitesForUserUuid($uuid)<br/>
return array('data' => $output)<br/><span style="line-height: 1.6em;">}</span></p></div><p>And this then allows me to instantiate in a phpunit test the same Repo but using Mockery so my unit test would look like this</p><div class="code prettify" style="background:#eee;border:1px solid #ccc;padding:5px 10px;"><p><span style="background-color: rgb(238, 238, 238);">//FooTest.php</span><br style="background-color: rgb(238, 238, 238);"/><span style="line-height: 1.6em;">public function setUp()</span></p><p>{<br/>
$this->repo = Mockery::mock('SiteRepository')<br/>
}</p></div><p>And later call to that method in the mocked class</p><div class="code prettify" style="background:#eee;border:1px solid #ccc;padding:5px 10px;"><p>//<span style="background-color: rgb(238, 238, 238);">FooTest.php</span><br/><span style="line-height: 1.6em;">public function test_getSitesAndOtherDataForUser()</span></p><p>{<br/>
$this->repo->shouldReceive('getSitesForUserUuid')->once()->andReturn(array(1,2,3));<br/>
}</p></div><p>This then allows me to quickly test how my code is dealing with the output. Maybe there is a filter, or other relations I am trying to pull in. As far as testing that the data structure is correct etc I save that for a test for that.</p><p>The Repository Class can look like this if using EntityQuery</p><div style="background:#eee;border:1px solid #ccc;padding:5px 10px;"><p>//SiteRepository.php</p><p>public $eq;</p><p>function __construct(\EntityFieldQuery $eq = null) {</p><p>$this->eq = ($eq == null) ? new \EntityFieldQuery() : $eq;</p><p>}</p><p>//Later on I can offer a method</p><p>function<span style="background-color: rgb(238, 238, 238);">getSitesForUserUuid($uuid){</span></p><p>$this->eq = do some query</p><p>}</p><p>//if we are not using EQ then just do your db_query in there</p><p>function getSitesForUserUuid($uudi) {</p><p>$results = db_query(foo);</p><p>return $results;</p><p>}</p></div></description><tags>testing</tags></item></channel></rss>